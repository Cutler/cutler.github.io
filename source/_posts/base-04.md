title: 第四章 Linux
date: 2016-7-15 18:06:20
categories: 编程基础
---
　　本章来介绍一下Linux系统基础知识，主旨是为大家日后深入学习Linux做铺垫。

# 第一节 基础入门 #
## 为什么要学习Linux ##
　　Linux应用广泛，从嵌入式设备、服务器领域到超级电脑，它都发挥着相当重要的作用。

	-  在嵌入式领域，流行的TiVo数字视频录像机还采用了定制的Linux，思科在网络防火墙和路由器也使用了定制的Linux。Linux也用于舞台灯光控制系统，如WholeHogIII控制台。在智能手机、平板电脑等移动设备方面，基于Linux内核的Android操作系统已经成为当今全球最流行的智能手机操作系统。
	-  在服务器领域，根据2006年9月Netcraft的报告显示，十个最大型的网络托管公司有八个公司在其Web服务器运行Linux发行版。Linux发行版是构成LAMP（Linux操作系统，Apache，MySQL，Perl / PHP / Python）的重要部分，LAMP是一个常见的网站托管平台，在开发者中已经得到普及。

　　因此笔者可以毫不负责任的说，一个程序员如果对Linux一窍不通的话，是说不过去的，更何况我们还是Android程序员。

## Linux常识 ##
　　如果你想了解Linux历史的话，可以去看看[《Linux入门很简单》](http://download.csdn.net/detail/baokx/8435171)一书，同时给大家推荐一个Linux学习网站： [实验楼](https://www.shiyanlou.com/)。
<br>**发行版与内核**
　　刚开始接触Linux时你一定会看到`Linux发型版`和`Linux内核`这两个概念：

	1、操作系统内核，通俗地说就是操作系统最核心最关键的部件，它负责一些最基本的工作，比如：管理硬件驱动、管理内存、管理文件系统、管理进程等等；这些工作只要少了任何一样，整个操作系统都没法运转。
	2、操作系统都有"内核"的概念，即Linux 和 Windows 都有其内核。
	3、但如果你使用 Windows，通常感觉不到"内核"的存在。为啥捏？原因在于：微软是把 Windows 当作一个整体来发布的。对于普通用户而言，你拿到的是一个完整的操作系统，所以你感觉不到"内核"的存在。而 Linux 不同于其它操作系统的地方在于：Linus 领导的开源社区只负责开发内核，不开发其它的东西（比如：运行库、图形界面、应用软件等）。
	4、这就引出一个问题——光有一个赤裸裸的内核，用户是没法用的（就好比你光拿到一个汽车引擎，你是没法开车的）。为此，就有一大帮开源社区或商业公司，在这个裸露的内核外面，再包上一些东西（比如：运行库、应用软件）。经过这样包装之后，就成为"发行版"。为啥 Linux 的发行版如此之多捏？前面俺说了，Linux 内核是彻底开放的，随便什么阿猫阿狗都可以去 Linux 的官网下载到内核。于是，发行版自然就很多啦。

<br>**通用发行版 VS 专用发行版**

	1、所谓的"通用发行版"，顾名思义就是：这个发行版可以派上各种用场；反之，"专用发行版"是为特定用途设计，只能用于某些特定场合。
    2、通用发行版名气比较大的有：Debian（非常强调"自由"的开源理念，它有很多衍生的发行版，形成一个大家族。）、Fedora、Slackware等。
    3、面向客户端（桌面）的专用发行版名气比较大的有：Ubuntu Desktop（衍生自Debian）、Mageia等。Ubuntu Desktop以发布时间做版本号（比如13.10 就是2013年10月发布）。每半年发布一个版本。它的版本分两种：普通版本和长期支持版本（LTS）。LTS 会持续提供支持（补丁更新）长达几年（桌面版 3年，服务器版 5年），普通版本只支持9个月。
    4、面向服务端的专用发行版名气比较大的有：Red Hat Enterprise Linux（简称 RHEL）、CentOS（从 RHEL 衍生）、Ubuntu Server（从 Debian 衍生）等等。

<br>**Shell**

	-  Shell是一个用C语言编写的应用程序，它提供了一个用户界面，用户通过在这个界面输入命令来访问操作系统内核的服务。
	   -  Linux下，很多工作都是通过命令完成的，学好Linux，首先要掌握常用Shell命令。
    -  为了防止重复编写代码，我们将一组Shell命令写在文件中，每次需要的时候就执行一下文件即可，这个文件就被称为Shell脚本。
    -  在 UNIX/Linux 中比较流行的 Shell 工具有 bash，zsh，ksh，csh 等等，Ubuntu 终端默认使用的是 bash。

<br>**内核版本**

	-  内核版本指的是在 Linus 领导下的开发小组开发出的系统内核的版本号。Linux 的每个内核版本使用形式为 x.y.zz-www 的一组数字来表示。其中：
       -  x.y：为linux的主版本号。通常y若为奇数，表示此版本为测试版，系统会有较多bug，主要用途是提供给用户测试。
       -  zz：为次版本号。
       -  www：代表发行号（注意，它与发行版本号无关）。
    -  当内核功能有一个飞跃时，主版本号升级，如 Kernel2.2、2.6等。而内核增加了少量补丁时，常常会升级次版本号，如Kernel2.6.15等。

<br>**体系结构**

	-  Linux从内到外依次分为四个层次：
       -  Hardware层：各类硬件，如硬盘、CPU等。
       -  Kernel层：内核直接与硬件交互，并处理大部分较低层的任务，如内存管理、进程调度、文件管理等。
       -  Shell层：Shell是一个处理用户请求的工具，它负责解释用户输入的命令，调用Kernel层提供的功能。如cp、mv、cat和grep等。
       -  Application层：各类应用程序，如：DBMS、Mail、FTP。


<br>
**本节参考阅读：**
- [维基百科 - Linux](https://zh.wikipedia.org/wiki/Linux)
- [扫盲 Linux：如何选择发行版](https://program-think.blogspot.com/2013/10/linux-distributions-guide.html)
- [Linux入门教程](http://c.biancheng.net/cpp/linux/)

## 文件系统 ##


### 分区与挂载 ###
　　与Windows一样，Linux中同样存在分区的概念，那么硬盘为什么要有分区呢？

	-  有利于管理，系统一般单独放一个区，这样由于系统区只放系统，其他区不会受到系统盘出现磁盘碎片的性能影响。
	-  如果一个分区出现逻辑损坏，仅损坏的分区而不是整个硬盘受影响。
	-  避免过大的日志或者其他文件占满导致整个计算机故障，将它们放在独立的分区，这样可能只有那一个分区出现空间耗尽。
	-  大硬盘搜索范围大，效率低。
	-  在运行Unix的多用户系统上，有可能需要防止用户的硬连结攻击。为了达到这个目的，/home和/tmp路径必须与如/var和/etc下的系统文件分开。

　　与Windows中每个分区对应一个盘（“C盘”、“D盘”）的情况不同，在Linux系统中普通用户是感觉不到分区的，Linux将整个文件系统看做一棵树，这棵树的树根叫做根文件系统，用“/”表示。
　　各个分区通过“挂载”（Mount）以文件夹的形式被放入到“/”下面。

	-  挂载是指将一个硬件设备（例如硬盘、U盘、光盘等）对应到一个已存在的目录上。 若要访问设备中的文件，必须将设备挂载到一个已存在的目录上， 然后通过访问这个目录来访问存储设备。


　　也就是说整个系统的所有文件，对于普通用户来说，都是放在“/”下的，“/”主要的目录有如下几个：

	/bin：存放操作系统运行所需要的可执行文件，所有用户都有权访问，例如：cat、ls、cp等命令。
    /boot：存放启动Linux时使用的一些核心文件，例如：kernal（系统内核）、initrd等。
    /dev：存放系统中的设备，从此目录可以访问各种系统设备，如磁盘驱动器，调制解调器，CPU，USB等。
    /etc：存放系统和应用软件的配置文件。
    /home：存放普通用户的个人文件。每个用户的主目录均在/home下以自己的用户名命名。
    /lib：存放/bin和/sbin中二进制文件所需要的库文件。
    /media：可移动设备的挂载点(如CD-ROM)。
    /mnt：临时挂载的文件系统。
    /opt：多数第三方软件默认安装到此位置，但并不是每个系统都会创建这个目录。
    /proc：虚拟文件系统，里面保存了内核和进程的状态信息，多为文本文件，可以直接查看。如/proc/cpuinfo保存了有关CPU的信息。
    /root：这是根用户的主目录。与保留给个人用户的/home下的目录很相似，该目录中还包含仅与根用户有关的条目。
    /sbin：root用户才能使用的系统二进制文件，例如： init、 ip、 mount等。
    /tmp：该目录用来保存临时文件，在系统重启时目录中文件不会被保留。
    /usr：用于存储只读用户数据的第二层次； 包含绝大多数的(多)用户工具和应用程序。
    /var：变量文件——在正常运行的系统中其内容不断变化的文件，如日志，脱机文件和临时电子邮件文件。有时是一个单独的分区。

<br>　　范例1：查看当前系统中的分区情况。
``` shell
# 使用df命令查看分区情况，-h参数表示以更容易阅读的方式显示结果，你可以去掉-h然后对比一下。
df -h

文件系统        容量  已用  可用 已用% 挂载点
udev           7.8G  4.0K  7.8G    1% /dev
tmpfs           1.6G  1.4M  1.6G    1% /run
/dev/sda3       883G  220G  619G   27% /
none            4.0K     0  4.0K    0% /sys/fs/cgroup
none            5.0M     0  5.0M    0% /run/lock
none            7.8G  108M  7.7G    2% /run/shm
none            100M   44K  100M    1% /run/user
/dev/sda1       496M   26M  471M    6% /boot/efi
```
    语句解释：
    -  分区必须挂载到一个目录下才能使用。
    -  上面的第一列是分区的名称，对于不同的硬盘，分区的名称不一样：
       -  对于IDE硬盘，名称以hd为前缀，后面跟着盘号（a、b、c、d），还有分区号（1、2、3、4）。
       -  对于SCSI硬盘，名称以sd为前缀，其它与IDE相同。
<br>
**本节参考阅读：**
- [维基百科 - 硬盘分区](https://zh.wikipedia.org/wiki/%E7%A1%AC%E7%9B%98%E5%88%86%E5%8C%BA)
- [维基百科 - FHS](https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%A0%87%E5%87%86)

### 文件与目录 ###
　　Linux中的所有数据都被保存在文件中，而且所有的文件被分配到不同的目录。
　　Linux有三种基本的文件类型：

	-  普通文件。普通文件是以字节为单位的数据流，包括文本文件、源码文件、可执行文件等。
	-  目录。目录可以包含普通文件、设备文件和另一个目录，目录相当于Windows和Mac OS中的文件夹。
	-  设备文件。Linux 与外部设备（例如光驱，打印机，终端，modern等）是通过一种被称为设备文件的文件来进行通信。Linux 输入输出到外部设备的方式和输入输出到一个文件的方式是相同的。Linux 和一个外部设备通讯之前，这个设备必须首先要有一个设备文件存在。
	   -  设备文件和普通文件不一样，设备文件中并不包含任何数据，即0字节。
	   -  设备文件有两种类型：字符设备文件和块设备文件。
	   -  字符设备文件的类型是"c"（具体后述），字符设备文件向设备传送数据时，一次传送一个字符。典型的通过字符传送数据的设备有终端、打印机等。
	   -  块设备文件的类型是"b"，块设备文件向设备传送数据时，先从内存中的buffer中读或写数据，而不是直接传送数据到物理磁盘。
	   -  磁盘和CD-ROMS既可以使用字符设备文件也可以使用块设备文件。

<br>　　接下来介绍几个文件相关的常用Shell命令。

　　范例1：文件操作。
``` shell
# 使用mkdir命令，在当前目录下创建一个名为myDir的文件夹。
# 在mkdir命令后面跟随“-p”可以连父目录一起创建（如果不存在的话）。
mkdir myDir

# 使用cd命令，进入到myDir文件夹中。
cd myDir

# 使用touch命令创建文件，如果想同时创建多个，那多个文件名之间使用空格间隔。
touch b.txt c.txt

# 使用ls命令，列出当前文件夹下的所有文件。在ls命令后面跟随“-l”参数可以同时把文件的详细信息列出来。
ls

# 使用rm命令，删除文件。其中*是通配符，表示删除所有文件，但不能删文件夹。
rm *

# 使用pwd命令查看当前所处的目录。
pwd
```
    语句解释：
    -  上面只是简单的介绍了各个命令，一般情况下每个命令都可以接受若干个参数。
    -  比如若你想使用rm命令删除一个文件夹，可以使用“rm -r myDir”，其中-r会删除myDir以及其内的所有文件。
    -  各命令的语法就不细说了，网上很容易搜索到。

<br>　　范例2：查找命令。
``` shell
# 使用find命令查找文件，下面命令的含义：从当前目录下的test目录中查找后缀名为txt的文件。
# 其中-name参数用来告诉find命令，按照文件名去查找，言外之意就是find命令还可以按照其它方式查找，比如文件权限等。
# 如果不指定查找的目录，则默认使用当前目录。
find test -name *.txt

# 使用grep命令查找文件里的内容，下面命令的含义：从test目录下的所有txt文件中搜索Hello关键字。
# 在grep命令后面加上-n参数可以把行号给列出来。
grep Hello test/*.txt
```
    语句解释：
    -  find和grep命令有很多附加参数，这里没法一一介绍，各位请自行搜索。

<br>　　范例3：复制、移动、重命名。
``` shell
# 使用cp命令复制文件，下面命令的含义：将当前目录下的b.txt复制到上一级目录中，并将复制过去的文件改名为bb.txt。
# 如果你想复制文件夹，可以在后面加一个-r参数。
cp b.txt ../bb.txt

# 使用mv命令移动文件，移动文件夹不需要夹任何参数。
mv b.txt ../
```
    语句解释：
    -  也可以用mv命令给文件和文件夹重命名，比如mv b.txt newb.txt。
    -  批量重命名可以使用rename命令，具体请自行搜索。

<br>　　范例4：查看与编辑。
``` shell
# 使用cat命令，可以把文件的全部内容给拿出来，使用-n参数可以加上行号。
cat -n result.txt

# 使用nl命令，也可以把文件全部内容给拿出来，但它在打印行号的功能上，比cat更专业。
# 这个命令有-b（设置是否给空行编号）和-n（设置行号的显示位置以及是否补0）两个参数，具体请自行搜索。
nl -n rz result.txt

# 使用more和less命令分页查看文件。
# 其中more命令打开文件后默认只显示一屏内容，可以使用Enter键向下滚动一行，使用Space键向下滚动一屏，按下h显示帮助，q退出。
more result.txt

# 使用head和tail命令，它们一个是只查看的头几行（默认为10行，不足10行则显示全部），另一个是只查看尾几行。
# 加上-n参数可以设置查看多少行。
# 关于tail命令，它有一个很牛的参数-f，这个参数可以实现不停地读取某个文件的内容并显示，这可让我们动态查看日志起到实时监视的作用。
head result.txt

# 使用file命令查看文件的类型。
file result.txt
```
    语句解释：
    -  cat不适合打开大文件（比如有成百上千行的文件），大文件推荐使用vim。

### 用户及文件权限管理 ###
　　Linux 是一个可以实现多用户登陆的操作系统，比如“李雷”和“韩梅梅”都可以同时登陆同一台主机，他们共享一些主机的资源，但是由于 Linux 的 用户管理 和 权限机制 ，不同用户不可以轻易地查看、修改彼此的文件。
　　下面我们就来学习一下 Linux 下的账户管理的基础知识。

　　首先，来看看“用户”和“用户组”的概念：

    -  在Linux中，系统中默认就存在了很多用户（主要是系统用户），而且每个用户都有一个归属（用户组）。
    -  用户组简单地理解就是一组用户的集合，它们共享一些资源和权限，同时拥有私有资源。
    -  用户组就跟家的形式差不多，你的兄弟姐妹（不同的用户）属于同一个家（用户组），你们可以共同拥有这个家（共享资源），爸妈对待你们都一样（共享权限）。
    -  你偶尔写写日记，其他人未经允许不能查看（私有资源和权限）。
    -  当然一个用户是可以属于多个用户组的，正如你既属于家庭，又属于学校或公司。

<br>　　范例1：查看所有用户以及所有用户组。
``` shell
# cut是一个选取命令，主要用来截取字符串。下面代码的含义为：
# 依次检查/etc/passwd文件中的每一行，将行内的数据按照“:”字符拆分成若干组，然后把第1组给显示出来。
cut -d : -f 1 /etc/passwd

# 相应的如果想知道系统中当前有多少个用户组，则可以执行：
cut -d : -f 1 /etc/group
```

<br>　　范例2：查看当前用户。
``` shell
who am i

输出：
cutler   pts/0       2016-07-19 15:24 (:0)
```
    语句解释：
    -  输出的第一列表示打开当前伪终端的用户的用户名（要查看当前登录用户的用户名，去掉空格直接使用 whoami 即可）。
    -  第二列的 pts/0 中 pts 表示伪终端，你每打开一个终端就会产生一个伪终端， pts/0后面那个数字就表示打开的伪终端序号，你可以尝试再打开一个终端，然后在里面输入 who am i ，看第二列是不是就变成 pts/1 了。
    -  第三列则表示当前伪终端的启动时间。

<br>　　范例3：查看指定用户所在的用户组。
``` shell
groups cutler

输出：
cutler : cutler adm cdrom sudo dip plugdev lpadmin sambashare
```
    语句解释：
    -  其中冒号之前表示用户，后面表示该用户所属的用户组，可以看到cutler拥有8个用户组。
    -  每次新建用户如果不指定用户组的话，默认会自动创建一个与用户名相同的用户组。

<br>　　然后，来看看“root”用户的概念：

	-  在 Linux 系统里， root 用户拥有整个系统至高无上的权利，比如添加/删除用户。所有对象它都可以操作，所以很多黑客在入侵系统的时候，都要把权限提升到 root 权限。
	-  另外在Android中获得 root 权限之后就意味着已经获得了手机的最高权限，这时候你可以对手机中的任何文件（包括系统文件）执行任意操作。
	-  我们一般登录系统时都是以普通账户的身份登录的，当需要执行root用户才能执行的操作时（比如创建用户），就要用到 sudo 这个命令了。
	-  不过使用这个命令有两个大前提，一是你要知道当前登录用户的密码，二是当前用户必须在 sudo 用户组。

<br>　　范例4：创建新用户。
``` shell
sudo adduser huye
```
    语句解释：
    -  笔者当前登陆的用户是cutler，它并不是root用户，为了让cutler可以创建用户，就在adduser命令之前加上了sudo命令。
    -  按照提示给新用户设置密码，后面的选项的一些内容你可以选择直接回车使用默认值。
    -  adduser命令不但可以添加用户到系统，同时也会默认为新用户创建home目录，执行“ls /home”命令就可以看到。
    -  使用“su 用户名”可以切换用户，切换完之后就可以使用“whoami”命令来验证，还可以去测试新用户是否可以执行sudo命令。
    -  退出当前用户跟退出终端一样可以使用 exit。

<br>　　范例5：给新用户添加sudo用户组。
``` shell
sudo usermod -G sudo huye

# 使用下面的命令可以删除用户。
# sudo deluser huye --remove-home
```
    语句解释：
    -  使用 usermod 命令可以为用户添加用户组，同样使用该命令你必需有 root 权限。
    -  你可以直接使用 root 用户为其它用户添加用户组，或者用其它已经在 sudo 用户组的用户使用 sudo 命令获取权限来执行该命令。
    -  然后再登陆到huye上后，就可以使用sudo命令了，而且通过“groups huye”命令也可以看到它已经被添加到sudo组里了。

<br>　　最后，我们来看看Linux文件权限相关的知识。

<br>　　范例6：查看文件的权限。
``` shell
ls -l

总用量 192
drwxrwxr-x 12 cutler cutler   4096  7月 14 11:35 a
-rw-rw-r--  1 cutler cutler   1562  6月 20 09:00 a.py
-rw-rw-r--  1 cutler cutler  33850  6月 15 19:19 cuihu_1.xlsx
-rw-rw-r--  1 cutler cutler 141824  6月 17 11:21 cuihu_2.xls
drwxrwxr-x  4 cutler cutler   4096  7月 14 11:39 jira384229
drwxrwxr-x  5 cutler cutler   4096  7月 14 14:15 monkeytest
```
    语句解释：
    -  命令输出了7部分内容，从左到右依次为：文件的类型和权限，链接数，所有者，所属用户组，文件大小，最后修改日期，文件名。

　　文件的类型和权限由10个字符组成，第一个字符表示文件的类型，’d‘表示目录，’-‘表示文件，具体如下图所示：

<center>
![](/img/android/android_base04_01.png)
</center>

　　图释：

	-  关于文件类型，这里有一点你必需时刻牢记Linux 里面一切皆文件，正因为这一点才有了设备文件（ /dev 目录下有各种设备文件，大都跟具体的硬件设备相关）这一说。
	-  读权限，表示你可以使用 cat 之类的命令来读取某个文件的内容。
	-  写权限，表示你可以编辑和修改某个文件。
	-  执行权限，通常指可以运行的二进制程序文件或者脚本文件，如同 Windows 上的 'exe' 后缀的文件。
	-  你需要注意的一点是，一个目录要同时具有读权限和执行权限才可以打开，而一个目录要有写权限才允许在其中创建其它文件。


　　明白了文件权限的一些概念，我们顺带补充一下关于`ls`命令的一些其它常用的用法。

<br>　　范例7：`ls`命令。
``` shell
# 显示所有隐藏文件（Linux 下以 '.' 开头的文件为隐藏文件，Linux程序（包括Shell）通常使用隐藏文件来保存配置信息）。
ls -A

# 你也可以同时使用A和l参数。
ls -Al

# 显示文件的大小，单位kb。
ls -s

#显示所有文件的大小，并以普通人能看懂的方式呈现。
ls -AsSh
```
    语句解释：
    -  大S为按文件大小排序，h用来在文件大小后面加上单位。

<br>　　如果你有一个自己的文件不想被其他用户读、写、执行，那么就需要对文件的权限做修改，这里有两种方式。
　　范例8：修改文件的访问权限。
``` shell
# 方式一：二进制数字表示。

# 每个文件都有的三组权限（拥有者，所属用户组，其他用户,记住这个顺序是一定的），我们用3位二进制数字表示。
# 对于"rwx"可以得到111，也就是一个十进制的'7'，因此“rwx------”对应的数字权限就应该是700。
chmod 700 a.txt


# 方式二：加减赋值操作，自己查去。
```
    语句解释：
    -  使用chmod命令来修改文件的权限。
    -  你也可以使用chown命令修改文件的拥有者、使用chgrp命令修改所属用户组。

## 环境变量 ##
　　Linux中同样存在环境变量的概念，在介绍环境变量之前，我们先来看看自定义变量。

<br>　　范例1：自定义变量。
``` shell
# 打开Shell窗口，输入如下命令来定义一个变量，其中declare关键字可以省写。
declare cutler="huye"

# 打印出变量的值，echo用来执行打印操作，在变量名前面加个$符号就可以访问变量值。
echo $cutler
```
    语句解释：
    -  自定义变量的作用于仅限于当前Shell窗口，窗口关闭后或者在另一个窗口中，是访问不到cutler变量的。

<br>　　自定义变量属于Shell编程的范畴，想了解更多内容的话，请自行搜索。
　　Linux的环境变量配置网上也有很多教程（包括PATH变量的配置），笔者就不再冗述了，请自行搜索。

## 管道 ##
　　有时候，我们可以把两个命令连起来使用，一个命令的输出作为另一个命令的输入，这就叫做管道。为了建立管道，需要在两个命令之间使用竖线(|)连接。
　　管道是Linux进程之间一种重要的通信机制；除了管道，还有共享内存、消息队列、信号、套接字(socket) 等进程通信机制。

<br>　　范例1：使用管道。
``` shell
# 列出当前目录下包含“cutler”关键字的文件的信息。
ls -l | grep 'cutler'

# grep支持使用正则去匹配，下面的命令只会匹配最后一个o，因为$表示结尾。
echo "oh, Hello" | grep ".*o$"
```
    语句解释：
    -  管道使用竖线(|)将两个命令隔开，竖线左边命令的输出就会作为竖线右边命令的输入。连续使用竖线表示第一个命令的输出会作为第二个命令的输入，第二个命令的输出又会作为第三个命令的输入，依此类推。
    -  grep命令有很多选项：
       -  -v 反转查询，输出不匹配的行。
       -  -n 输出匹配的行以及行号。
       -  等等。

<br>　　范例2：awk和sort命令。
``` shell
# 首先获取出/etc/passwd文件的内容，然后把结果传给awk命令。
# 接着awk会依次对每一行进行处理，即以‘:’符为分隔符，拆分每一行字符串，并且将该行的第一个值给输出。
# 最后使用sort命令对awk的输出进行排序。
cat /etc/passwd | awk -F ':' '{print $1}' | sort
```
    语句解释：
    -  awk和sort命令还支持很多附加参数（比如sort可以按数字的大小排序等），详细情况请自行搜索。

<br>
**本节参考阅读：**
- [Linux管道和过滤器](http://c.biancheng.net/cpp/html/2732.html)


# 第二节 Linux内核 #
　　Linux内核主要的功能有：进程管理、内存管理、虚拟文件系统、设备控制、网络，每一个功能都涉及到大量的知识，本节只会介绍相关的理论，更深层的原理就需要靠各位自己了。

## 进程管理 ##
<br>**父进程 & 子进程**

	-  在Linux里，每个进程都有一个唯一标识自己的ID，即PID。
	-  除了进程0（即PID=0的交换进程，Swapper Process）以外的所有进程都是由其他进程使用系统调用fork创建的。
	-  调用fork创建新进程的进程即为父进程，而相对应的为其创建出的进程则为子进程。
	-  因而除了进程0以外的进程都只有一个父进程，但一个进程可以有多个子进程。
	-  进程0是系统引导时创建的一个特殊进程，在其调用fork创建出一个子进程（即PID=1的进程1，又称init）后，进程0就转为交换进程（有时也被称为空闲进程），而进程1（init进程）就是系统里其他所有进程的祖先。

<br>　　范例1：查看进程树。
``` shell
# 以树形结构来显示各个进程的继承关系。
pstree
```
    语句解释：
    -  自定

```
cat /proc/sys/kernel/pid_max
```
第2章 进程管理
知识结构：
第1节 进程的引入
第2节 进程的控制
第3节 进程通信
第4节 进程调度
第5节 死锁与线程

2.1  进程的引入

程序的分类：
|-  源程序：某种高级语言或者汇编语言编写的程序称为源程序。 
|-  目标程序：使用编译程序可以将源程序编译成目标程序。
|-  可执行程序：将目标程序链接后，生成可执行程序。

程序的执行过程：编辑、编译、链接、执行。
程序的结构：顺序结构、分支结构、循环结构。

前驱图：

在顺序结构中，一个较大的程序通常分为若干个程序段执行，各段必须按照先后次序关系逐个执行，这种先后次序关系可用前驱图来表示。
所谓的前驱图，就和数据结构中的拓扑排序类似。是一个有向无环图。
如下图所示：

如果想进行运算操作，必须要先有输入，然后再运算，最后再输出。每一步的顺序都不能颠倒。
程序顺序执行的特征：
|-  顺序性：程序的各程序段严格按照规定的顺序执行，从上到下，从左到右。
|-  封闭性：程序运行时独占全机资源，计算机内各资源的状态，只有本程序才可以改变它，程序执行结果，与外界无关。
|-  可在现性：只要程序执行环境和初始条件相同，程序多次执行的结果就相同。 
 |-  所谓的顺序执行，简单的说，就是在内存中只有一个程序在占有CPU。
|-  如：单道批处理OS。
前驱图中某个结点的直接前驱没有被执行，则这个结点就不可以被执行。

程序并发执行的特点：
|-  所谓的并发执行，简单的说，就是在内存中有多个程序在轮流占有CPU。 
|-  第一，并发执行的多个程序会相互制约。如下前驱图所示：

   |-  此时a1必须在a2之前执行。而a2和b1也必须在b2之前执行。 
|-  如果内存中，有两个进程，一个从a1开始执行，另一个从b1开始执行。由于是并发执行，所以当前时刻是哪个进程占有CPU、占有多久等都是随机的，假设b1开始执行，并且执行到了b2 。此时，a1才开始执行。刚才说了，a2和b1也必须在b2之前执行，此时只执行了b1而a2则并没有执行，所以进程只有等待a2执行结束后，才可以执行b2 。
|-  这就是所谓的相互制约。说白了，就是需要等待。
|-  第二，失去了程序的封闭性。
   |-  内存中有多个程序在执行，各个程序轮流占有CPU。如果当前CPU正处于工作状态，则外面的进程就需要等待CPU 。这就导致程序的执行受到了外界的干扰(如果内存中只有一个进程在执行，则根本就不需要等待)，从而失去封闭性。
|-  第三，不可再现性。
   |-  并发执行就意味着随机性。虽然程序执行的初始条件和环境相同，但是每次执行的结果可能就不相同(不可再现)。这一点在Java多线程就有很好的体验。如果不明白，可以看我写的《Java》一书。在此，不再冗述。

程序与进程：

进程是程序的一次执行。程序本身只是一块死代码、指令的集合。程序需要被加载到内存中后，才可以执行。而程序被加载入内存，OS就会为其启动一个进程。

进程：是OS中资源分配的基本单位。
   |-  说白了，OS分配内存等资源时，是以进程为单位进行分配的。
   |-  一个进程可以有父进程和子进程。
      |-  父进程： 创造当前进程的进程。
      |-  子进程： 当前进程创建的进程。
   |-  建立子进程时，会重新申请内存资源，而不是在当前进程中划分。
   |-  现代操作系统中，线程是调度的基本单位。(原因后述)。
程序：
|-  它是一个静态概念，是指令和数据的集合，长期存储在磁盘中。

进程与程序的区别：
|-  状态：
|-  程序是静态的，咱们写的源代码就是程序，它是长期存放在磁盘上的。
|-  进程是动态的，程序被载入内存并运行时，OS就会为其启动一个进程。
|-  存在时间：
   |-  由于程序是存放在硬盘上的代码。所以，只要硬盘不坏，那么会一直存在。
   |-  进程是暂时的，它有起点有终点。如：咱们登录QQ时，会开启一个进程，当咱们关闭QQ时，进程占据的内存会被释放，此时内存就结束了。
|-  数据结构：
   |-  程序根本就不能被直接执行，只是一段死代码。
   |-  每一个被载入到内存中的进程，都具有一个PCB ，它和咱们人类的心脏是一样的，如果一个进程没有了PCB，那么唯一的原因就是，它已经“去逝”(消失)了。
      |-  以后，只要看到“数据结构”这四个字，那么就可以简单的认为，就是C语言中的一个“结构体”，当然，这是片面的，所以，出去后不要乱说。因为数据结构包括“数据的逻辑结构、存储结构、结构的行为特征”，逻辑结构指的是“数据及数据间的联系”。而结构体只能算是数据结构中描述数据的工具。总之，为了便于您理解，所以，才让您将数据结构想象成为一个“结构体”。在此，就可以认为PCB就是一个结构体。
|-  具体关于数据结构的知识，请看我写的另一本数《数据结构》一书。

为什么要引入进程？
|-  在没有进程的系统中，程序的计算操作和IO操作必须顺序执行，即要么先执行IO操作，要么先执行计算操作。它们不能同时执行。
|-  引入进程后，可分别为计算程序和IO程序各建立一个进程，则这两个进程就可以并发执行。多个进程可以相互切换，当失去CPU的进程再次被调度的时候，会根据其PCB中的数据，还原程序现场。但是若没有进程，则就无法保存当前作业的执行情况。也就无法并发执行。也就回到了顺序执行的阶段了。

进程与程序对应关系：
|-  一个程序可以对应一个进程或多个进程。
   |-  但是，大部分情况下都是一个程序对应一个进程。如打开一个Windows中的记事本程序，就会开启一个进程。
|-  一个进程可以对应一个程序，或者一段程序。
   |-  某一段程序，需要调用打印机打印，则这段程序，就对应一个打印进程。


进程实体通常由：程序、数据和进程控制块(PCB)组成。
|-  程序：就是代码，描述了进程需要完成的功能。
|-  数据：程序执行的所需要的数据及工作区。
|-  进程控制块：是进程存在的唯一标志。
   |-  所谓的创建进程，其实就是创建进程的PCB，撤销进程，就是撤销进程的PCB。
   |-  操作系统是根据PCB来对并发执行的进程进行控制和管理的。
      |-  当OS要调度某一个进程时，要从该进程的PCB中查出现行状态及优先级。

提示：程序只是一段死(静态)代码，根本就没法执行，何谈并发执行？并发执行的是进程而不是程序。

PCB：
PCB中保存的信息：
|-  进程标识符：用于唯一地标识一个进程，一个进程通常有两种标识符。
   |-  内部标识符：
      |-  操作系统分配给进程的一个唯一的ID 。就像是咱们的身份证号。内部标识符主要为了方便操作系统使用。
   |-  外部标识符：
      |-  咱们用户对进程的称呼。 就像是咱们的姓名。一般在其他进程调用本进程时使用。
|-  处理机状态。
|-  进程调度信息：进程状态、进程优先级、进程调度的其他信息。
|-  进程控制信息。

PCB的组织形式：
|-  链队：每个进程都对应一个PCB，内存中的所有PCB通常使用链式指针，链接起来。
|-  使用链队链接的时候，不论进程处于何种状态，都将它们放到一个统一的链表中。
|-  此种方式适合于PCB不多的情况下。	
|-  因为如果OS要调用一个就绪的进程，则需要从链表头开始寻找。浪费时间。
|-  表格结构：PCB在内存中按照原来的顺序排列，但是另建立一些表，不同的进程按照不同的状态被放到不同的表中。
   |-  就绪进程表、阻塞进程表、执行进程表(保存当前正在执行的进程，在多CPU的系统中)。以此来提高效率。
   |-  OS只需要分别记载每个PCB表的起始地址。当要调用一个就绪的进程时，可以节省查找时间。

进程的状态和转换

进程的状态：一个进程从产生至消亡的整个生命期间所处的各个状态。为了充分利用系统资源，将进程划分为若干状态。
|-  三态模型：
   |-  运行状态：进程正在占有CPU 。
      |-  当某个进程获得CPU时，就进入了运行状态。
   |-  就绪状态：进程具备运行条件，等待系统分配处理器以便运行。
      |-  一个进程在创建后将处于就绪状态。
      |-  该进程的CPU时间片结束，或在抢占式调度中有更高优先权进程请求占有CPU时，当前进程就从运行状态，转变为就绪状态。
   |-  等待状态：又称为阻塞态或睡眠态，指进程不具备运行条件，正在等待某个事件的完成。此时，即使把CPU分给该进程，它也无法运行。
      |-  当等待的事件已经完成时(如IO结束)，该进程就从等待状态进入就绪状态。

注意：就绪状态不能直接向阻塞状态转变，阻塞状态也不能直接向运行状态转变。

|-  五态模型：
      |-  新增了：新建状态和终止状态。
      |-  此时建立一个进程分为两个阶段：
         |-  建立阶段：为一个新进程创建一个PCB，并填写必要的管理信息。
|-  提交阶段：将这个进程转为就绪状态，并放入就绪队列中。
            |-  操作系统有时会限制推迟新建态进程的提交。
         |-  新建状态对应于进程刚刚创建且没有提交状态。此时进程还没有进入内存。
      |-  相应的进程的终止也分为两个阶段：
         |-  第一个阶段：将进程从就绪队列中取出，并等待操作系统进行善后处理。
         |-  第二个阶段：然后将PCB清空，并释放进程所占据的内存。
         |-  当进程到达了自然结束点，或是出现无法克服的错误时，它将进入终止态。
|-  进入终止态的进程以后不再执行，但依然保留在操作系统中等待善后。一旦其他进程完成了对终止态进程的信息抽取之后，操作系统将删除该进程。

提示：
在程序被运行后，系统首先要做的就是为该进程建立一个默认线程(即主线程)，然后程序可以根据需要自行添加或删除相关的线程。
扩展：进程就绪队列。
在多道程序设计系统中，往往会同时创建多个进程，这些被创建的若干就绪进程可按一定次序排成队列，即就绪队列。
同一队列中的进程通过进程控制块中的队列指针联系起来。
|-  一个进程从所在的队列中退出称为出队，
|-  一个进程排入到一个指定的队列中称为入队。
系统中负责进程入队和出队的工作称为队列管理。
	
提示：
在某些系统中允许父进程在任何情况下终止子进程。且如果父进程终止了，则其所有的子进程也会被终止。 因此，在此种系统中进程的任何状态都可以转换成终止状态。

在一些系统中，进程除了具有上述状态外，还具有挂起状态。
	由于多任务系统中，内存中允许存在多个进程，且内存的空间是有限的，因此内存中进程的数量也是有限的，当内存的空间已经耗尽时，可以采用两种方式，继续运行新的进程：
|-  交换(swapping)技术： 
   |-  将内存中一些暂时不用的进程或暂时不用的程序和数据，暂时存放到外存中，然后腾出内存空间，接着让具备运行条件的进程 进入内存。这就是“交换”。
   |-  当进程被换入外存时，它的状态被变为挂起状态。
|-  虚拟存储技术：
   |-  每个进程只装入一部分程序和数据,然后就开始运行。其他部分，等需要的时候再装入。

提示：为什么进程调用IO，就进入阻塞状态。
  阻塞，可以理解为等待。 在高级语言中，当程序执行到scanf()等函数的时候，进程就会挂在那里等待用户输入数据，此时进程就是调用了IO，且进入了阻塞状态。

名词：
|-  活动就绪：就是普通的就绪状态。
   |-  OS有时会暂时挂起就绪的进程，以释放内存空间。
|-  静态就绪：当进程就绪后，被挂起，此时进程就处于静态就绪。
   |-  当OS调入静态就绪的进程时，则该进程进入活动就绪状态。
   |-  如果无足够的内存，分配给一个新的进程，则新进程会直接进入静态就绪状态。
|-  活动阻塞：就是普通的阻塞状态。
|-  静态阻塞：当进程阻塞后，被挂起，此时进程就处于静态阻塞。
   |-  当静态阻塞的进程，等待的事件发生时，进程就进入，静态就绪状态。

2.2  进程的控制
机器指令和特权指令：
计算机的基本功能是执行程序。
程序就是指令的集合。因此最终被执行的是存储在内存中的机器指令。
处理器根据程序计数器（PC）从内存中取一条指令到指令寄存器（IR）并执行它。

CPU中指令系统中的机器指令分为两类：
|-  特权指令
   |-  顾名思义,一般的用户程序不能调用的指令。
   |-  只能提供给操作系统或其他系统程序使用的指令。
|-  非特权指令
   |-  咱们的程序中可以执行的指令。

操作系统能执行全部指令(特权指令和非特权指令),用户程序中不能执行特权指令。若执行了特权指令，会导致非法执行而产生中断。

处理器的状态：
	为避免用户程序中使用特权指令，CPU具有两种工作状态：目态和管态。
	|-  管态：
       |-  OS占用CPU时，CPU就处于管态。此时可以执行全部指令。
|-  目态：
   |-  用户程序占用CPU时，CPU就处于目态。此时不允许执行特权指令。
       |-  此时,若CPU得到特权指令，CPU将拒绝执行该指令，并形成一个“程序中使用了非法指令”的信号。

   现代操作系统都有一条“访管指令”。
|-  它是在目态下执行的指令，用户程序通过访管指令来向OS请求服务。执行到访管指令时，CPU从目态变为管态。然后由操作系统分析访管指令中的参数，然后让相应的“系统调用”子程序为用户服务。服务完了之后，管态变回目态。

程序状态字
程序状态字(PSW) 每个正在执行的程序都有一个与其执行相关的 PSW。每个CPU都设置一个程序状态字寄存器。一个程序占有CPU执行，它的 PSW 将被放到程序状态字寄存器中。
PSW寄存器包括三部分：
|-  程序基本状态：
|-  程序计数器：指明下一条执行的指令地址；
|-  条件码：表示指令执行的结果状态；
|-  处理器状态位：指明当前的处理器状态，如目态或管态、运行或等待。
|-  终端码。
|-  中断屏蔽位。

进程的控制：
处理器管理的一个主要工作之一是对进程控制。主要包括：
|-  创建进程、阻塞进程、唤醒进程、挂起进程、激活进程和撤销进程等。
|-  进程的控制由OS内核(Kernel)中的原语实现。

原语(Primitive)
|-  是在管态下执行、由若干条机器指令组成的，用于完成特定功能的程序段。
|-  原语和机器指令类似，其特点是执行过程中不允许被中断，是一个不可分割的基本单位(要么都做，要么都不做)，原语的执行是顺序的也不可能是并发的。


原语与系统调用：
相同点：
|-  原语和系统调用都使用访管指令实现，具有相同的调用形式。
不同点：
|-  原语由内核来实现。系统调用由系统进程或系统服务器实现。
|-  原语不可中断。系统调用执行时允许被中断。
|-  通常情况下，原语提供给系统进程或系统服务器使用。系统进程或系统服务器提供系统调用给系统(和用户) 程序使用。 

|-  创建进程：使用创建原语。
   |-  首先，申请一个空白的PCB。
|-  然后，为新进程分配内存等资源。
|-  接着，初始化进程控制块。
|-  最后，将进程放入到就绪队列中。
|-  阻塞进程：一个进程让出处理器，去等待一个事件。使用阻塞原语。
|-  如等待资源、等待 I/O完成等。
|-  引起阻塞的原因，通常都是进程自己调用阻塞原语阻塞自己。
|-  唤醒进程：当一个等待事件(如IO完成)结束会产生一个中断，从而，激活操作系统，在系统的控制之下将被阻塞的进程唤醒。使用唤醒原语。
|-  提示：操作系统这门课程是有前驱课程的，所以如果基础不牢，学起来就费劲。
挂起进程：系统在超过一定的时间没有任何动作等情况下，进程就会被挂起。引入挂起主要的目的是为了缓和内存紧张的状况，将进程放到磁盘对换区中。
|-  进程挂起需要使用挂起原语。挂起原语既可由进程自己也可由其他进程调用。正在运行的进程也可以直接挂起。
|-  激活进程：当系统资源尤其是内存资源充裕或一个进程请求激活指定进程时，系统或有关进程会调用激活原语把指定进程激活。
|-  激活原语却只能由其他进程调用。不能由待激活进程调用。
|-  撤销进程：一个进程完成了特定的工作或出现了严重的异常后，操作系统则收回它占有的内存地址空间和进程控制块，此时就说撤销了一个进程。使用撤销原语。 

进程的切换：
|-  当某进程时间片结束。
|-  当某进程IO阻塞。
|-  内存出错等。

还有就是，系统进行进程切换(多个程序轮流占有CPU) 时，不是简简单单就可以完成的。需要分别保存和恢复相应进程现场，修改进程状态，调整和更新表格和队列。

进程的同步：
处理器管理的一个主要工作之一是对进程同步。
计算机中，多个进程可以并发执行，每个进程都以各自独立的、以不可预知的速度向前推进。 进程间产生接触是必然的，为了保证程序执行的正确性，必须对多个进程进行同步。
进程同步：主要任务是协调多个进程的运行。协调方式有两种：
|-  互斥方式：当两个进程同时访问一个临界资源时，只有先来的可以访问，后来的进程必须等待其访问结束后。
|-  同步方式：假设有两个进程A和B 。A需要对一个文件进行写入操作，B需要从文件中将A写入的数据读出来。如果B执行的比A快，则B就需要等待A将数据写入到文件后，才可以读取。

互斥方式和同步方式： 
|-  互斥是申请临界资源进程间的间接制约问题。
  |-  所谓的间接制约，就是通过临界资源来制约。
|-  如，打印机只能被一个进程访问，那么正在打印机内部执行的进程就通过打印机间接制约外面的进程。要求外面的进程，必须等待。进程间是竞争的关系。
  |-  说白了，一个临界资源同一时间只能被一个进程访问，谁先来，谁就先访问。
|-  同步是合作进程间的直接制约问题。
|-  说白了，就是一个进程的继续执行，是以另一个进程的执行结束为前提。若进程A未结束，则即使进程B早到了，它也必须等待。进程间是合作的关系。

扩展：
当一个程序执行到输入输出语句时，可以启动专门负责IO的系统服务程序完成IO操作。不再需要CPU来操作。

2.3  进程通信

在多道程序设计的系统中，由于多个进程可以并发执行，因此进程间必然存在资源共享和相互合作。
扩展：
　多道程序设计技术是指在内存同时放若干道程序，使它们在系统中并发执行，共享系统中的各种资源。当一道程序暂停执行时，CPU立即转去执行另一道程序。

临界区：
前面说，进程间同步的方式有：互斥方式和同步方式。但是如何实现呢？
答：通过临界区+信号量机制来实现。

不论是硬件临界资源，还是软件临界资源，多个进程必须互斥地对它进行访问。每个进程中访问临界资源的那段代码称为临界区(Critical Section)。临界区是隶属于进程的。

临界区管理的原则：
|-  有空则进：当无进程处于临界区时，允许进程进入其自己的临界区，并且只能运行有限的时间。
|-  无空则等：当有一个进程在临界区时，其他需要进入(其自己的)临界区的进程也必须等待。
|-  有限等待：对要求访问临界资源的进程，应保证其等待时间是有限的。以免陷入“饥饿”状态。
|-  让权等待：当进程在临界区门口等待时，应立即释放CPU。使其他进程可以执行。免陷入“忙等”状态。

信号量机制：
PV操作：
|-  PV和栈的弹栈、压栈类似。都是进行增、删的操作。
   |-  P操作表示申请一个资源。
   |-  V操作表示释放一个资源。
|-  PV操作是由进程来控制完成的。

设一个整型变量S，用来保存当前系统中剩余的资源数量。此时：
|-  进行P操作时,S减去1 。
   |-  P从当前系统中申请一个资源，因此当前可用资源S要减少一个。
      |-  执行完P操作后(也就是S-1之后)：
         |-  S>=0 ,说明系统中本来就有资源,申请成功,当前进程继续向下执行。
         |-  S<0 ,说明申请失败。申请失败，则进程就要在此等待，什么时间有资源了，什么时间再次申请。其中|S| = 当前正在等待的进程的个数。
|-  进行V操作时,S 增加1 。
|-  同理,V释放一个已用的资源，因此当前可用资源S要增加一个。
      |-  执行完V操作后(也就是S+1之后)：
         |-  S>0 ,说明系统中现在有空闲资源。
      |-  S<=0 ,说明S原来的值为负数,即系统中有进程正在等待，所以要从等待队列(队首)中取出一个进程，将这个资源，交给它。即唤醒一个进程。然后执行V操作的进程，继续向下执行。

    信号量：
|-  上面使用的变量S就被称为是信号量。对S进行P操作，记作P(S) 。相应的也有V(S) 。
|-  信号量机制分为：
|-  整型信号量。(咱们只讨论整型的信号量)
|-  记录型信号量。
|-  信号量集机制。
    |-  信号量是最早出现的用来解决进程同步与互斥问题的机制,包括一个称为信号量的变量及对它进行的两个原语操作(PV)。

范例1：利用PV操作实现进程互斥。

首先，在内存中，进程A和进程B是并发执行的。谁先执行、谁后执行，是不确定的。
然后，回想一下，互斥操作的含义，以打印机为例，如果A正在使用，则B就只能等待，此时A和B的关系就是互斥。
接着，设信号量S=1。
|-  “临界区”中的代码用来操作“临界资源”。
随后，咱们假设进程A先开始执行。
|-  执行到P(S)时，从系统中申请一个资源，S=S-1 。 此时S = 0 说明申请成功。当前进程进入临界区。假设当A处于其临界区内，正在进行操作的时候，时间片结束了。 
|-  恰巧进程B被分到了CPU时间片，那么A就无法执行了，被挂在了临界区中。
|-  然后B执行到B的P(S)时，从系统中申请一个资源，S=S-1 。 此时S = -1 。而-1意味着申请失败，当前系统中，没有资源了，所以，B进程必须原地等待。B无法进入的临界区中。
|-  由于B的等待，导致CPU→转回到A进程的手中，然后A进程继续操作。
|-  当A进程操作完毕后，从临界区中走出。然后执行V(S) ，来释放一个资源，S=S+1 。 此时S = 0 。说明刚才系统中有进程再等待，A将其唤醒后(这里只是唤醒B，B此时处于就绪状态，在A的时间片没结束前，B只有看的份)，A继续执行其他语句。
|-  过了一会，A进程的CPU时间再次结束，B再次获得CPU控制权，然后直接进入(不再减一)临界区进行操作。
|-  若此时A又回来了，则执行到P(S)时，S = S – 1 。此时S = -1 。因此 A等待。

提示：
进程如果进入等待状态，则需要别的进程将其唤醒。   
进程等待时，不会被分配到CPU时间片。   

再提示：
使用信号量实现进程间互斥操作的时候，信号量的初值必须为>=1 。否则会造成，所有进程都在等待，而临界资源却一直空闲。初值>=1 的信号量被称为公共信号量。

范例2：利用PV操作实现进程同步。
进程同步操作和线程的同步是一样的原理，参看我写的《Java》一书中的第四章 多线程。其中的“厨师与食客”就是一个典型的“生产者与消费者”的例子。
在此，简单的说说“厨师与食客”。
|-  现在有一张桌子，桌子上只能存放5盘菜。
   |-  有一个厨师不断的做菜，然后将菜放到桌子上。如果桌子满了，则就停止做菜。
   |-  有一个食客不断的吃菜。如果桌子空了，则就歇会。
|-  吃菜和放菜不能同时进行。
   |-  若厨师先执行。则厨师一开始检测一下，桌子上的菜是否为5：
|-  如果为5，证明已经满了，则厨师进入等待。CPU此时会转交给食客。
|-  否则，则厨师做一盘菜放到桌子上，并唤醒食客吃。
   |-  若食客先执行。则食客一开始检测一下，桌子上的菜是否为0：
|-  如果为0，证明已经空了，则食客进入等待。CPU此时会转交给厨师。
|-  否则，则食客吃一盘菜，并唤醒厨师继续做。
   


通过观察：
|-  首先，在进程同步的时候需要使用两个信号量。
|-  然后，对某一个信号量的PV操作被分别放到不同的进程中。而在进程互斥中PV操作则存在于同一进程中。
|-  接着，在同步时，信号量的初值为>=0 。初值为>=0 的信号量被称为“私用信号量”。
提示：
使用PV进行同步操作的时候，同样，如果不满足条件，则进程需要在临界区外面等待，当资源充足时，再由另一个进程将其唤醒。
若程序中同时存在互斥和同步操作：
|-  设S1为同步信号量，S2为互斥信号量。
|-  那么P(S1)一定要放在P(S2)之前。否则可能出现死锁。

高级通信原语：
进程间的通信方式
|-  PV通信方式：
   |-  PV属于低级通信。编程难度大，操作不当容易引起死锁，且效率低。
|-  高级通信方式：
   |-  共享存储系统：相互通信的进程共享某些数据结构(或存储区)，实现进程之间的通信。
   |-  消息传递系统：进程间的数据交换以消息为单位，程序员直接利用系统提供的一组通信命令(原语)来实现通信。
      |-  发送消息： send(目的地,消息内容)
      |-  接收消息： receive(消息来源)
   |-  管道通信：
      |-  管道(pipeline)：是连接读写进程的一个特殊的文件，允许进程按先进先出方式传送数据，也能使进程同步执行操作。
      |-  发送进程(进程A)将管道当作输出文件，以字符流形式把大量数据送入管道。
|-  接收进程(进程B)将管道当作输入文件，从管道中接收数据。
|-  这种通信方式叫管道通信。如图所示：


直接通信和间接通信：

直接通信：
|-  顾名思义，两个通信的进程间没有中介物，它们直接进行交流。
   |-  设有A和B两个进程：
|-  A发送数据 send(B,”你好”)
|-  B接受数据 receive(A)
间接通信：
|-  同理，两个通信的进程间有中介物。
   |-  设有A和B两个进程：
      |-  A发送数据 send(C,”你好”)
      |-  B接受数据 receive(C)
|-  间接通信是以信箱为媒体来实现通信的，接受信件的进程只需设立一个信箱，若干个进程可以向同一个进程发送信件。


进程管理又称为处理机管理。
多个进程可以被调度在一个处理器上交替执行，或在多个处理器上同时执行。不同类型的操作系统可能采用不同的调度策略。
单处理器系统：只具有一个CPU。多处理器系统：具有多个CPU。
目前计算机系统可分为如下四类：
 	  |-  单指令流单数据流(Single Instruction Single Data ，SISD)。
         |-  一条指令控制了一个CPU操作一个的数据。
|-  单指令流多数据流(Single Instruction Multiple Data ，SIMD)。
   |-  一条指令控制了多个CPU对不同的数据进行了操作。
  |-  多指令流单数据流(MISD)。
     |-  一个数据流被传送给一组处理器，通过这一组处理器上的不同指令操作最终得到处理结果。该类计算机系统的研究尚在实验室阶段。
  |-  多指令流多数据流(MIMD)。
     |-  多个CPU对各自不同的数据集同时执行不同的指令流。
     |-  分类：
|-  共享内存的紧密耦合 MIMD 系统
   |-  主从式系统 (MSP)
       |-  在一个特别的处理器上运行操作系统内核。
|-  其他处理器上则运行用户程序和操作系统例行程序。
|-  内核负责分配和调度各个处理器，并向其它程序提供各种服务。
|- 如：输入/输出。
                   |-  缺点：主处理器的崩溃会导致整个系统的崩溃。
|-  对称式系统 (SMP)
    |-  操作系统内核可以运行在任意一个处理器上。
|-  每个处理器都可以自我调度运行的进程和线程。
|-  单个进程的多个线程可在不同处理器上同时运行。
|-  内存分布的松散耦合 MIMD 系统
   |-  每个处理单元都有一个独立的内存储器。各个处理单元之间通过网线等相连。多计算机系统和集群(Cluster)系统都是松散耦合 MIMD 系统的例子。
2.4  进程调度
一个计算机中的CPU数量，一般都低于进程的数量，因此，为了保证进程的执行，需要进行进程调度。

调度的方式：

进程调度方式分为：
|-  可剥夺式：
   |-  当有更高优先级的进程请求CPU服务时，CPU会立刻放弃当前正在执行的进程，转而去为高优先级的进程提供服务。
|-  不可剥夺式：
   |-  和上面的相对应。必须等待当前进程自动放弃CPU后，才将CPU给高优先级的进程使用。

三级调度：
	进程的调度也被称为“处理机的调度”。进程调度分为三级：
|-  高级调度：
   |-  又称为“作业调度”，用来把后续的作业从输入池(外存)调入内存运行。
      |-  在批处理OS中需要使用高级调度，将作业调入内存。
      |-  在实时OS和分时OS中，用户可以直接通过键盘将输入命令。因此，它们不需要高级调度。 而且系统中一个作业只需要经历一次高级调度。
|-  中级调度：
   |-  又称为“对换调度” 在内、外存对换区进行进程对换。
   |-  回想一下，进程挂起就是为了缓和内存紧张，而将进程放到磁盘对换区中。
   |-  中级调度，可以将对换区中的进程，放到内存中来。如果内存紧张，则要先将内存中的阻塞进程放到对换区中，然后再将对换区中的进程取出，即所谓的“对换”。
|-  低级调度：又称为“进程调度”。
|-  它决定内存中就绪队列的哪个进程可以获得CPU。

调度算法：
常用的进程调度算法有如下几种：
|-  先来先服务(FCFS)：
   |-  按照作业提交或者进程变为就绪状态的先后次序分配CPU。
   |-  每当调度进程的时，总是将就绪队列队首的进程投入运行。此种调度方式，有利于CPU繁忙的作业，而不利于IO繁忙的作业。(一个作业老是需要IO操作,但是进程的调度却是先到先服务，IO操作效率低) 。FCFS主要用于宏观调控。
|-  时间片轮转：
   |-  将系统中所有就绪进程按照FCFS原则排成一个队列，每次调用时将CPU分派给队首进程，让其执行一个时间片，时间片一到，发生时钟中断，将该进程送到就绪队列末尾，并切换执行当前的队首进程。主要用于微观调控。
   |-  时间片的长度：
      |-  固定时间片：分给每个进程的时间片相等。
      |-  可变时间片：根据进程不同的要求对时间片的大小实时修改。
|-  优先级调度：
   |- 每一个进程都有一个优先级，进程调度的时候，总是选择优先级高(数值大)的进程。优先级调度分为：
     |-  静态优先级：
        |-  进程的优先级在创建的时候就确定了，直到进程终止都不会改变。
     |-  动态优先级：
        |-  在创建进程时赋予一个优先级，在进程运行过程中还可以改变，以便获得更好的调度性能。
        |-  在就绪队列中，随着等待时间的增长，进程的优先级将提高。当等待足够长的时间后，就可能被调度执行。当每执行完一个时间片后，就降低该进程的优先级。当一个进程持续执行时，其优先级就会降低到让出CPU。
|-  多级反馈调度：
   |-  是时间片轮转法和优先级算法的综合。

2.5  死锁与线程
关于死锁：说白了就是：You first,You first问题。
双方谁都不愿意先做，导致最终相互等待。
比如说：
  ·  抢劫犯要求： 你们先给我钱，我放人。
  ·  受害者家属要求： 你先放人，我们给你钱。

双方都手持着对方想要的东西不放，且还想得到对方的东西。最终结果就是 相互僵持着。这就是死锁。

产生死锁的条件：
|-  互斥条件：
   |-  进程请求占有的资源是临界资源。同一时间只允许一个进程占有。
|-  请求保持条件：
   |-  进程已经占有了一个临界资源。但又提出新的资源申请，其申请占有的资源又被另一个进程占有。于是该进程阻塞，但其原先获得的资源保持不放。
|-  不可剥夺条件：
   |-  进程已获得的资源在未使用完之前，不能被剥夺，只能在使用完后，由自己释放。
|-  环路条件：
   |-  当发生死锁时，在进程资源有向图中存在环路。
      |-  说白了，A进程占有一个临界资源，B进程也占有一个临界资源。
|-  A和B都不想放弃自己的资源，同时又想占有对方的资源。然后就互相等待。

提示：模拟死锁的过程，请参看我写的另一本书《算法设计》 。
 
线程(Thread)

进程是操作系统的基本组成单位。进程既是资源分配单位，又是调度和执行单位。
|-  线程是程序运行的基本单元。  线程隶属于进程。
|-  一个进程中可以有多个线程。当一个进程消失了，那么进程中的所有线程都将死亡。
|-  一个进程中的所有线程，共享进程的内存空间。
|-  一个线程死亡了 进程却可能仍在运行着。线程不是程序，不能独立运行。
|-  多线程 简单的说就是可以使  一个进程在同一个时间段内可以做多个工作。
    
	引入线程的原因：
    |-  在进程的创建、撤销、切换中，系统必须为之付出较大的时候开销。因此在系统中设置的进程数目不能过多，进程切换的频率不宜太高，这就限制了并发程度的提高。因此在现代操作系统中，引入了线程。此时进程仅仅是OS进行资源分配的基本单位，调度的基本单位变为了线程。

提示：
线程被称为轻型进程。
线程与进程的根本区别是把进程作为资源分配单位，而线程是调度和执行的单位。
一个线程中可以建立另一个线程，同一个进程中可以有多个线程并发执行。

一个标准的线程由：线程ID、当前指令指针(PC)、寄存器集合和堆栈组成。同样具有就绪、运行、阻塞三个基本状态。
线程的优点：
|-  创建一个新线程花费的时间少。
|-  两个线程的切换时间少。除了必要的组成部分，线程几乎不拥有资源。
|-  由于同一个进程内的线程共享内存和文件，所以线程之间互相通信必须调用内核。 　　|-  线程能独立执行，能充分利用和发挥处理机与外围设备并行工作的能力。



<br>
**本节参考阅读：**
- [Linux基础：进程管理](http://wuchong.me/blog/2014/07/24/linux-process-manage/)
- [维基百科 - 父进程](https://zh.wikipedia.org/wiki/%E7%88%B6%E8%BF%9B%E7%A8%8B)



1、进程管理

 内核负责创建和销毁进程, 并处理它们与外部世界的联系(输入和输出). 不同进程间通讯(通过信号, 管道, 或者进程间通讯原语)对整个系统功能来说是基本的, 也由内核处理. 另外, 调度器, 控制进程如何共享 CPU, 是进程管理的一部分. 更通常地, 内核的进程管理活动实现了多个进程在一个单个或者几个 CPU 之上的抽象.

2、内存管理

 计算机的内存是主要的资源, 处理它所用的策略对系统性能是至关重要的. 内核为所有进程的每一个都在有限的可用资源上建立了一个虚拟地址空间. 内核的不同部分与内存管理子系统通过一套函数调用交互, 从简单的 malloc/free 对到更多更复杂的功能.

## 内存管理 ##



http://www.cnblogs.com/lcw/p/3159395.html
http://c.biancheng.net/cpp/html/2733.html
http://xuding.blog.51cto.com/4890434/1741861
http://www.ha97.com/1036.html
http://wuchong.me/blog/2014/07/24/linux-process-manage/
https://www.ibm.com/developerworks/cn/linux/kernel/syscall/part2/
http://www.cnblogs.com/vamei/archive/2012/09/20/2694466.html
http://www.cnblogs.com/mickole/p/3185610.html

https://zh.wikipedia.org/wiki/%E7%88%B6%E8%BF%9B%E7%A8%8B
https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%A1%A8


<br><br>
　　







