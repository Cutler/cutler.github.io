title: 第四章 Linux
date: 2016-7-15 18:06:20
categories: 编程基础
---
　　本章来介绍一下Linux系统基础知识，主旨是为大家日后深入学习Linux做铺垫。

# 第一节 基础入门 #
## 为什么要学习Linux ##
　　Linux应用广泛，从嵌入式设备、服务器领域到超级电脑，它都发挥着相当重要的作用。

	-  在嵌入式领域，流行的TiVo数字视频录像机还采用了定制的Linux，思科在网络防火墙和路由器也使用了定制的Linux。Linux也用于舞台灯光控制系统，如WholeHogIII控制台。在智能手机、平板电脑等移动设备方面，基于Linux内核的Android操作系统已经成为当今全球最流行的智能手机操作系统。
	-  在服务器领域，根据2006年9月Netcraft的报告显示，十个最大型的网络托管公司有八个公司在其Web服务器运行Linux发行版。Linux发行版是构成LAMP（Linux操作系统，Apache，MySQL，Perl / PHP / Python）的重要部分，LAMP是一个常见的网站托管平台，在开发者中已经得到普及。

　　因此笔者可以毫不负责任的说，一个程序员如果对Linux一窍不通的话，是说不过去的，更何况我们还是Android程序员。

## Linux常识 ##
　　如果你想了解Linux历史的话，可以去看看[《Linux入门很简单》](http://download.csdn.net/detail/baokx/8435171)一书，同时给大家推荐一个Linux学习网站： [实验楼](https://www.shiyanlou.com/)。
<br>**发行版与内核**
　　刚开始接触Linux时你一定会看到`Linux发型版`和`Linux内核`这两个概念：

	1、操作系统内核，通俗地说就是操作系统最核心最关键的部件，它负责一些最基本的工作，比如：管理硬件驱动、管理内存、管理文件系统、管理进程等等；这些工作只要少了任何一样，整个操作系统都没法运转。
	2、操作系统都有"内核"的概念，即Linux 和 Windows 都有其内核。
	3、但如果你使用 Windows，通常感觉不到"内核"的存在。为啥捏？原因在于：微软是把 Windows 当作一个整体来发布的。对于普通用户而言，你拿到的是一个完整的操作系统，所以你感觉不到"内核"的存在。而 Linux 不同于其它操作系统的地方在于：Linus 领导的开源社区只负责开发内核，不开发其它的东西（比如：运行库、图形界面、应用软件等）。
	4、这就引出一个问题——光有一个赤裸裸的内核，用户是没法用的（就好比你光拿到一个汽车引擎，你是没法开车的）。为此，就有一大帮开源社区或商业公司，在这个裸露的内核外面，再包上一些东西（比如：运行库、应用软件）。经过这样包装之后，就成为"发行版"。为啥 Linux 的发行版如此之多捏？前面俺说了，Linux 内核是彻底开放的，随便什么阿猫阿狗都可以去 Linux 的官网下载到内核。于是，发行版自然就很多啦。

<br>**通用发行版 VS 专用发行版**

	1、所谓的"通用发行版"，顾名思义就是：这个发行版可以派上各种用场；反之，"专用发行版"是为特定用途设计，只能用于某些特定场合。
    2、通用发行版名气比较大的有：Debian（非常强调"自由"的开源理念，它有很多衍生的发行版，形成一个大家族。）、Fedora、Slackware等。
    3、面向客户端（桌面）的专用发行版名气比较大的有：Ubuntu Desktop（衍生自Debian）、Mageia等。Ubuntu Desktop以发布时间做版本号（比如13.10 就是2013年10月发布）。每半年发布一个版本。它的版本分两种：普通版本和长期支持版本（LTS）。LTS 会持续提供支持（补丁更新）长达几年（桌面版 3年，服务器版 5年），普通版本只支持9个月。
    4、面向服务端的专用发行版名气比较大的有：Red Hat Enterprise Linux（简称 RHEL）、CentOS（从 RHEL 衍生）、Ubuntu Server（从 Debian 衍生）等等。

<br>**Shell**

	-  Shell是一个用C语言编写的应用程序，它提供了一个用户界面，用户通过在这个界面输入命令来访问操作系统内核的服务。
	   -  Linux下，很多工作都是通过命令完成的，学好Linux，首先要掌握常用Shell命令。
    -  为了防止重复编写代码，我们将一组Shell命令写在文件中，每次需要的时候就执行一下文件即可，这个文件就被称为Shell脚本。
    -  在 UNIX/Linux 中比较流行的 Shell 工具有 bash，zsh，ksh，csh 等等，Ubuntu 终端默认使用的是 bash。

<br>**内核版本**

	-  内核版本指的是在 Linus 领导下的开发小组开发出的系统内核的版本号。Linux 的每个内核版本使用形式为 x.y.zz-www 的一组数字来表示。其中：
       -  x.y：为linux的主版本号。通常y若为奇数，表示此版本为测试版，系统会有较多bug，主要用途是提供给用户测试。
       -  zz：为次版本号。
       -  www：代表发行号（注意，它与发行版本号无关）。
    -  当内核功能有一个飞跃时，主版本号升级，如 Kernel2.2、2.6等。而内核增加了少量补丁时，常常会升级次版本号，如Kernel2.6.15等。

<br>**体系结构**

	-  Linux从内到外依次分为四个层次：
       -  Hardware层：各类硬件，如硬盘、CPU等。
       -  Kernel层：内核直接与硬件交互，并处理大部分较低层的任务，如内存管理、进程调度、文件管理等。
       -  Shell层：Shell是一个处理用户请求的工具，它负责解释用户输入的命令，调用Kernel层提供的功能。如cp、mv、cat和grep等。
       -  Application层：各类应用程序，如：DBMS、Mail、FTP。


<br>
**本节参考阅读：**
- [维基百科 - Linux](https://zh.wikipedia.org/wiki/Linux)
- [扫盲 Linux：如何选择发行版](https://program-think.blogspot.com/2013/10/linux-distributions-guide.html)
- [Linux入门教程](http://c.biancheng.net/cpp/linux/)

## 文件系统 ##


### 分区与挂载 ###
　　与Windows一样，Linux中同样存在分区的概念，那么硬盘为什么要有分区呢？

	-  有利于管理，系统一般单独放一个区，这样由于系统区只放系统，其他区不会受到系统盘出现磁盘碎片的性能影响。
	-  如果一个分区出现逻辑损坏，仅损坏的分区而不是整个硬盘受影响。
	-  避免过大的日志或者其他文件占满导致整个计算机故障，将它们放在独立的分区，这样可能只有那一个分区出现空间耗尽。
	-  大硬盘搜索范围大，效率低。
	-  在运行Unix的多用户系统上，有可能需要防止用户的硬连结攻击。为了达到这个目的，/home和/tmp路径必须与如/var和/etc下的系统文件分开。

　　与Windows中每个分区对应一个盘（“C盘”、“D盘”）的情况不同，在Linux系统中普通用户是感觉不到分区的，Linux将整个文件系统看做一棵树，这棵树的树根叫做根文件系统，用“/”表示。
　　各个分区通过“挂载”（Mount）以文件夹的形式被放入到“/”下面。

	-  挂载是指将一个硬件设备（例如硬盘、U盘、光盘等）对应到一个已存在的目录上。 若要访问设备中的文件，必须将设备挂载到一个已存在的目录上， 然后通过访问这个目录来访问存储设备。


　　也就是说整个系统的所有文件，对于普通用户来说，都是放在“/”下的，“/”主要的目录有如下几个：

	/bin：存放操作系统运行所需要的可执行文件，所有用户都有权访问，例如：cat、ls、cp等命令。
    /boot：存放启动Linux时使用的一些核心文件，例如：kernal（系统内核）、initrd等。
    /dev：存放系统中的设备，从此目录可以访问各种系统设备，如磁盘驱动器，调制解调器，CPU，USB等。
    /etc：存放系统和应用软件的配置文件。
    /home：存放普通用户的个人文件。每个用户的主目录均在/home下以自己的用户名命名。
    /lib：存放/bin和/sbin中二进制文件所需要的库文件。
    /media：可移动设备的挂载点(如CD-ROM)。
    /mnt：临时挂载的文件系统。
    /opt：多数第三方软件默认安装到此位置，但并不是每个系统都会创建这个目录。
    /proc：虚拟文件系统，里面保存了内核和进程的状态信息，多为文本文件，可以直接查看。如/proc/cpuinfo保存了有关CPU的信息。
    /root：这是根用户的主目录。与保留给个人用户的/home下的目录很相似，该目录中还包含仅与根用户有关的条目。
    /sbin：root用户才能使用的系统二进制文件，例如： init、 ip、 mount等。
    /tmp：该目录用来保存临时文件，在系统重启时目录中文件不会被保留。
    /usr：用于存储只读用户数据的第二层次； 包含绝大多数的(多)用户工具和应用程序。
    /var：变量文件——在正常运行的系统中其内容不断变化的文件，如日志，脱机文件和临时电子邮件文件。有时是一个单独的分区。

<br>　　范例1：查看当前系统中的分区情况。
``` shell
# 使用df命令查看分区情况，-h参数表示以更容易阅读的方式显示结果，你可以去掉-h然后对比一下。
df -h

文件系统        容量  已用  可用 已用% 挂载点
udev           7.8G  4.0K  7.8G    1% /dev
tmpfs           1.6G  1.4M  1.6G    1% /run
/dev/sda3       883G  220G  619G   27% /
none            4.0K     0  4.0K    0% /sys/fs/cgroup
none            5.0M     0  5.0M    0% /run/lock
none            7.8G  108M  7.7G    2% /run/shm
none            100M   44K  100M    1% /run/user
/dev/sda1       496M   26M  471M    6% /boot/efi
```
    语句解释：
    -  分区必须挂载到一个目录下才能使用。
    -  上面的第一列是分区的名称，对于不同的硬盘，分区的名称不一样：
       -  对于IDE硬盘，名称以hd为前缀，后面跟着盘号（a、b、c、d），还有分区号（1、2、3、4）。
       -  对于SCSI硬盘，名称以sd为前缀，其它与IDE相同。
<br>
**本节参考阅读：**
- [维基百科 - 硬盘分区](https://zh.wikipedia.org/wiki/%E7%A1%AC%E7%9B%98%E5%88%86%E5%8C%BA)
- [维基百科 - FHS](https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%A0%87%E5%87%86)

### 文件与目录 ###
　　Linux中的所有数据都被保存在文件中，而且所有的文件被分配到不同的目录。
　　Linux有三种基本的文件类型：

	-  普通文件。普通文件是以字节为单位的数据流，包括文本文件、源码文件、可执行文件等。
	-  目录。目录可以包含普通文件、设备文件和另一个目录，目录相当于Windows和Mac OS中的文件夹。
	-  设备文件。Linux 与外部设备（例如光驱，打印机，终端，modern等）是通过一种被称为设备文件的文件来进行通信。Linux 输入输出到外部设备的方式和输入输出到一个文件的方式是相同的。Linux 和一个外部设备通讯之前，这个设备必须首先要有一个设备文件存在。
	   -  设备文件和普通文件不一样，设备文件中并不包含任何数据，即0字节。
	   -  设备文件有两种类型：字符设备文件和块设备文件。
	   -  字符设备文件的类型是"c"（具体后述），字符设备文件向设备传送数据时，一次传送一个字符。典型的通过字符传送数据的设备有终端、打印机等。
	   -  块设备文件的类型是"b"，块设备文件向设备传送数据时，先从内存中的buffer中读或写数据，而不是直接传送数据到物理磁盘。
	   -  磁盘和CD-ROMS既可以使用字符设备文件也可以使用块设备文件。

<br>　　接下来介绍几个文件相关的常用Shell命令。

　　范例1：文件操作。
``` shell
# 使用mkdir命令，在当前目录下创建一个名为myDir的文件夹。
# 在mkdir命令后面跟随“-p”可以连父目录一起创建（如果不存在的话）。
mkdir myDir

# 使用cd命令，进入到myDir文件夹中。
cd myDir

# 使用touch命令创建文件，如果想同时创建多个，那多个文件名之间使用空格间隔。
touch b.txt c.txt

# 使用ls命令，列出当前文件夹下的所有文件。在ls命令后面跟随“-l”参数可以同时把文件的详细信息列出来。
ls

# 使用rm命令，删除文件。其中*是通配符，表示删除所有文件，但不能删文件夹。
rm *

# 使用pwd命令查看当前所处的目录。
pwd
```
    语句解释：
    -  上面只是简单的介绍了各个命令，一般情况下每个命令都可以接受若干个参数。
    -  比如若你想使用rm命令删除一个文件夹，可以使用“rm -r myDir”，其中-r会删除myDir以及其内的所有文件。
    -  各命令的语法就不细说了，网上很容易搜索到。

<br>　　范例2：查找命令。
``` shell
# 使用find命令查找文件，下面命令的含义：从当前目录下的test目录中查找后缀名为txt的文件。
# 其中-name参数用来告诉find命令，按照文件名去查找，言外之意就是find命令还可以按照其它方式查找，比如文件权限等。
# 如果不指定查找的目录，则默认使用当前目录。
find test -name *.txt

# 使用grep命令查找文件里的内容，下面命令的含义：从test目录下的所有txt文件中搜索Hello关键字。
# 在grep命令后面加上-n参数可以把行号给列出来。
grep Hello test/*.txt
```
    语句解释：
    -  find和grep命令有很多附加参数，这里没法一一介绍，各位请自行搜索。

<br>　　范例3：复制、移动、重命名。
``` shell
# 使用cp命令复制文件，下面命令的含义：将当前目录下的b.txt复制到上一级目录中，并将复制过去的文件改名为bb.txt。
# 如果你想复制文件夹，可以在后面加一个-r参数。
cp b.txt ../bb.txt

# 使用mv命令移动文件，移动文件夹不需要夹任何参数。
mv b.txt ../
```
    语句解释：
    -  也可以用mv命令给文件和文件夹重命名，比如mv b.txt newb.txt。
    -  批量重命名可以使用rename命令，具体请自行搜索。

<br>　　范例4：查看与编辑。
``` shell
# 使用cat命令，可以把文件的全部内容给拿出来，使用-n参数可以加上行号。
cat -n result.txt

# 使用nl命令，也可以把文件全部内容给拿出来，但它在打印行号的功能上，比cat更专业。
# 这个命令有-b（设置是否给空行编号）和-n（设置行号的显示位置以及是否补0）两个参数，具体请自行搜索。
nl -n rz result.txt

# 使用more和less命令分页查看文件。
# 其中more命令打开文件后默认只显示一屏内容，可以使用Enter键向下滚动一行，使用Space键向下滚动一屏，按下h显示帮助，q退出。
more result.txt

# 使用head和tail命令，它们一个是只查看的头几行（默认为10行，不足10行则显示全部），另一个是只查看尾几行。
# 加上-n参数可以设置查看多少行。
# 关于tail命令，它有一个很牛的参数-f，这个参数可以实现不停地读取某个文件的内容并显示，这可让我们动态查看日志起到实时监视的作用。
head result.txt

# 使用file命令查看文件的类型。
file result.txt
```
    语句解释：
    -  cat不适合打开大文件（比如有成百上千行的文件），大文件推荐使用vim。

### 用户及文件权限管理 ###
　　Linux 是一个可以实现多用户登陆的操作系统，比如“李雷”和“韩梅梅”都可以同时登陆同一台主机，他们共享一些主机的资源，但是由于 Linux 的 用户管理 和 权限机制 ，不同用户不可以轻易地查看、修改彼此的文件。
　　下面我们就来学习一下 Linux 下的账户管理的基础知识。

　　首先，来看看“用户”和“用户组”的概念：

    -  在Linux中，系统中默认就存在了很多用户（主要是系统用户），而且每个用户都有一个归属（用户组）。
    -  用户组简单地理解就是一组用户的集合，它们共享一些资源和权限，同时拥有私有资源。
    -  用户组就跟家的形式差不多，你的兄弟姐妹（不同的用户）属于同一个家（用户组），你们可以共同拥有这个家（共享资源），爸妈对待你们都一样（共享权限）。
    -  你偶尔写写日记，其他人未经允许不能查看（私有资源和权限）。
    -  当然一个用户是可以属于多个用户组的，正如你既属于家庭，又属于学校或公司。

<br>　　范例1：查看所有用户以及所有用户组。
``` shell
# cut是一个选取命令，主要用来截取字符串。下面代码的含义为：
# 依次检查/etc/passwd文件中的每一行，将行内的数据按照“:”字符拆分成若干组，然后把第1组给显示出来。
cut -d : -f 1 /etc/passwd

# 相应的如果想知道系统中当前有多少个用户组，则可以执行：
cut -d : -f 1 /etc/group
```

<br>　　范例2：查看当前用户。
``` shell
who am i

输出：
cutler   pts/0       2016-07-19 15:24 (:0)
```
    语句解释：
    -  输出的第一列表示打开当前伪终端的用户的用户名（要查看当前登录用户的用户名，去掉空格直接使用 whoami 即可）。
    -  第二列的 pts/0 中 pts 表示伪终端，你每打开一个终端就会产生一个伪终端， pts/0后面那个数字就表示打开的伪终端序号，你可以尝试再打开一个终端，然后在里面输入 who am i ，看第二列是不是就变成 pts/1 了。
    -  第三列则表示当前伪终端的启动时间。

<br>　　范例3：查看指定用户所在的用户组。
``` shell
groups cutler

输出：
cutler : cutler adm cdrom sudo dip plugdev lpadmin sambashare
```
    语句解释：
    -  其中冒号之前表示用户，后面表示该用户所属的用户组，可以看到cutler拥有8个用户组。
    -  每次新建用户如果不指定用户组的话，默认会自动创建一个与用户名相同的用户组。

<br>　　然后，来看看“root”用户的概念：

	-  在 Linux 系统里， root 用户拥有整个系统至高无上的权利，比如添加/删除用户。所有对象它都可以操作，所以很多黑客在入侵系统的时候，都要把权限提升到 root 权限。
	-  另外在Android中获得 root 权限之后就意味着已经获得了手机的最高权限，这时候你可以对手机中的任何文件（包括系统文件）执行任意操作。
	-  我们一般登录系统时都是以普通账户的身份登录的，当需要执行root用户才能执行的操作时（比如创建用户），就要用到 sudo 这个命令了。
	-  不过使用这个命令有两个大前提，一是你要知道当前登录用户的密码，二是当前用户必须在 sudo 用户组。

<br>　　范例4：创建新用户。
``` shell
sudo adduser huye
```
    语句解释：
    -  笔者当前登陆的用户是cutler，它并不是root用户，为了让cutler可以创建用户，就在adduser命令之前加上了sudo命令。
    -  按照提示给新用户设置密码，后面的选项的一些内容你可以选择直接回车使用默认值。
    -  adduser命令不但可以添加用户到系统，同时也会默认为新用户创建home目录，执行“ls /home”命令就可以看到。
    -  使用“su 用户名”可以切换用户，切换完之后就可以使用“whoami”命令来验证，还可以去测试新用户是否可以执行sudo命令。
    -  退出当前用户跟退出终端一样可以使用 exit。

<br>　　范例5：给新用户添加sudo用户组。
``` shell
sudo usermod -G sudo huye

# 使用下面的命令可以删除用户。
# sudo deluser huye --remove-home
```
    语句解释：
    -  使用 usermod 命令可以为用户添加用户组，同样使用该命令你必需有 root 权限。
    -  你可以直接使用 root 用户为其它用户添加用户组，或者用其它已经在 sudo 用户组的用户使用 sudo 命令获取权限来执行该命令。
    -  然后再登陆到huye上后，就可以使用sudo命令了，而且通过“groups huye”命令也可以看到它已经被添加到sudo组里了。

<br>　　最后，我们来看看Linux文件权限相关的知识。

<br>　　范例6：查看文件的权限。
``` shell
ls -l

总用量 192
drwxrwxr-x 12 cutler cutler   4096  7月 14 11:35 a
-rw-rw-r--  1 cutler cutler   1562  6月 20 09:00 a.py
-rw-rw-r--  1 cutler cutler  33850  6月 15 19:19 cuihu_1.xlsx
-rw-rw-r--  1 cutler cutler 141824  6月 17 11:21 cuihu_2.xls
drwxrwxr-x  4 cutler cutler   4096  7月 14 11:39 jira384229
drwxrwxr-x  5 cutler cutler   4096  7月 14 14:15 monkeytest
```
    语句解释：
    -  命令输出了7部分内容，从左到右依次为：文件的类型和权限，链接数，所有者，所属用户组，文件大小，最后修改日期，文件名。

　　文件的类型和权限由10个字符组成，第一个字符表示文件的类型，’d‘表示目录，’-‘表示文件，具体如下图所示：

<center>
![](/img/android/android_base04_01.png)
</center>

　　图释：

	-  关于文件类型，这里有一点你必需时刻牢记Linux 里面一切皆文件，正因为这一点才有了设备文件（ /dev 目录下有各种设备文件，大都跟具体的硬件设备相关）这一说。
	-  读权限，表示你可以使用 cat 之类的命令来读取某个文件的内容。
	-  写权限，表示你可以编辑和修改某个文件。
	-  执行权限，通常指可以运行的二进制程序文件或者脚本文件，如同 Windows 上的 'exe' 后缀的文件。
	-  你需要注意的一点是，一个目录要同时具有读权限和执行权限才可以打开，而一个目录要有写权限才允许在其中创建其它文件。


　　明白了文件权限的一些概念，我们顺带补充一下关于`ls`命令的一些其它常用的用法。

<br>　　范例7：`ls`命令。
``` shell
# 显示所有隐藏文件（Linux 下以 '.' 开头的文件为隐藏文件，Linux程序（包括Shell）通常使用隐藏文件来保存配置信息）。
ls -A

# 你也可以同时使用A和l参数。
ls -Al

# 显示文件的大小，单位kb。
ls -s

#显示所有文件的大小，并以普通人能看懂的方式呈现。
ls -AsSh
```
    语句解释：
    -  大S为按文件大小排序，h用来在文件大小后面加上单位。

<br>　　如果你有一个自己的文件不想被其他用户读、写、执行，那么就需要对文件的权限做修改，这里有两种方式。
　　范例8：修改文件的访问权限。
``` shell
# 方式一：二进制数字表示。

# 每个文件都有的三组权限（拥有者，所属用户组，其他用户,记住这个顺序是一定的），我们用3位二进制数字表示。
# 对于"rwx"可以得到111，也就是一个十进制的'7'，因此“rwx------”对应的数字权限就应该是700。
chmod 700 a.txt


# 方式二：加减赋值操作，自己查去。
```
    语句解释：
    -  使用chmod命令来修改文件的权限。
    -  你也可以使用chown命令修改文件的拥有者、使用chgrp命令修改所属用户组。

## 环境变量 ##
　　Linux中同样存在环境变量的概念，在介绍环境变量之前，我们先来看看自定义变量。

<br>　　范例1：自定义变量。
``` shell
# 打开Shell窗口，输入如下命令来定义一个变量，其中declare关键字可以省写。
declare cutler="huye"

# 打印出变量的值，echo用来执行打印操作，在变量名前面加个$符号就可以访问变量值。
echo $cutler
```
    语句解释：
    -  自定义变量的作用于仅限于当前Shell窗口，窗口关闭后或者在另一个窗口中，是访问不到cutler变量的。

<br>　　自定义变量属于Shell编程的范畴，想了解更多内容的话，请自行搜索。
　　Linux的环境变量配置网上也有很多教程（包括PATH变量的配置），笔者就不再冗述了，请自行搜索。

## 管道 ##
　　有时候，我们可以把两个命令连起来使用，一个命令的输出作为另一个命令的输入，这就叫做管道。为了建立管道，需要在两个命令之间使用竖线(|)连接。
　　管道是Linux进程之间一种重要的通信机制；除了管道，还有共享内存、消息队列、信号、套接字(socket) 等进程通信机制。

<br>　　范例1：使用管道。
``` shell
# 列出当前目录下包含“cutler”关键字的文件的信息。
ls -l | grep 'cutler'

# grep支持使用正则去匹配，下面的命令只会匹配最后一个o，因为$表示结尾。
echo "oh, Hello" | grep ".*o$"
```
    语句解释：
    -  管道使用竖线(|)将两个命令隔开，竖线左边命令的输出就会作为竖线右边命令的输入。连续使用竖线表示第一个命令的输出会作为第二个命令的输入，第二个命令的输出又会作为第三个命令的输入，依此类推。
    -  grep命令有很多选项：
       -  -v 反转查询，输出不匹配的行。
       -  -n 输出匹配的行以及行号。
       -  等等。

<br>　　范例2：awk和sort命令。
``` shell
# 首先获取出/etc/passwd文件的内容，然后把结果传给awk命令。
# 接着awk会依次对每一行进行处理，即以‘:’符为分隔符，拆分每一行字符串，并且将该行的第一个值给输出。
# 最后使用sort命令对awk的输出进行排序。
cat /etc/passwd | awk -F ':' '{print $1}' | sort
```
    语句解释：
    -  awk和sort命令还支持很多附加参数（比如sort可以按数字的大小排序等），详细情况请自行搜索。

<br>
**本节参考阅读：**
- [Linux管道和过滤器](http://c.biancheng.net/cpp/html/2732.html)


# 第二节 Linux内核 #
　　Linux内核主要的功能有：进程管理、内存管理、虚拟文件系统、设备控制、网络，每一个功能都涉及到大量的知识，本节只会介绍相关的理论，更深层的原理就需要靠各位自己了。

## 进程管理 ##
　　先来介绍一下Linux进程管理相关的知识，作为一个Android系统程序员不懂Linux进程管理的话，那是说不过去的。

### 基础知识 ###
<br>**进程**

　　为什么要引入进程？

	-  在没有进程的系统中，程序的计算操作和IO操作必须顺序执行，即要么先执行IO操作，要么先执行计算操作，它们不能同时执行。
	-  引入进程后，可分别为计算程序和IO程序各建立一个进程，则这两个进程就可以并发执行。多个进程可以相互切换，当失去CPU的进程再次被调度的时候，会根据其PCB中的数据，还原程序现场。


　　进程通常由：程序、数据和进程控制块(PCB)组成。

	-  程序：就是代码，描述了进程需要完成的功能。
	-  数据：程序执行的所需要的数据及工作区。
	-  进程控制块：是进程存在的唯一标志。
	   -  每一个进程均有一个PCB，在创建进程时，建立PCB，伴随进程运行的全过程，直到进程撤消而撤消。

　　进程PCB中保存的信息：

	-  进程标识符：用于唯一地标识一个进程，一个进程通常有两种标识符。
	   -  内部标识符：操作系统分配给进程的唯一的数字ID，即PID（Process ID）。
	   -  外部标识符：一个字符串，因为数字不便于记忆，所以每个进程除了数字外，还有一个字符串唯一标识。
	-  进程状态：可以是new、ready、running、waiting或 blocked等。
	-  进程调度信息：进程状态、进程优先级、进程调度的其他信息。
　　其中某些信息是会动态变化的，如进程的运行状态。

<br>**父进程 & 子进程**

	-  在Linux里，每个进程都有一个唯一标识自己的ID，即PID。
	-  除了进程0（即PID=0的交换进程，Swapper Process）以外的所有进程都是由其他进程使用系统调用fork创建的。
	-  调用fork创建新进程的进程即为父进程，而相对应的，被创建出的进程则为子进程。
	-  因而除了进程0以外的进程都只有一个父进程，但一个进程可以有多个子进程。
	-  进程0是系统引导时创建的一个特殊进程，在其调用fork创建出一个子进程（即PID=1的进程1，又称init）后，进程0就转为交换进程（有时也被称为空闲进程），而进程1（init进程）就是系统里其他所有进程的祖先。

　　范例1：查看进程树。
``` shell
# 以树形结构来显示各个进程的继承关系。
pstree
```
    语句解释：
    -  从命令的输出结果可以看出，init是最顶层的进程。


<br>**进程的创建**

　　前面说过，Linux中的所有进程（除了0号进程）都是其父进程调用fork函数创建的。

　　除此之外，还有一些知识需要知道：

	-  子进程被创建时，除了执行必要的初始化外，系统还需要为它创建PCB以及分配PID。
	-  通常情况下，子进程的PID会在父进程的PID上+1，且PID的最大值是32767，当超过了这个上限后，PID就开始循环使用已闲置的小PID号。
	-  所谓的创建子进程，其实就是创建一个父进程的副本，把这个副本当做新进程来用，副本会复制父进程内存的内容、线程以及线程执行到的位置等。
	-  子进程创建完毕后，子进程和父进程就会各自独立的运行了，父进程会继续执行fork函数的下一条语句，由于子进程是完整复制父进程，所以子进程也会从fork函数的下一句执行。
	-  不同的是，父进程调用fork函数后，得到的返回值是子进程的PID，而子进程从fork函数中得到的返回值却是0。

<br>　　范例1：查看进程ID的取值范围。
``` shell
cat /proc/sys/kernel/pid_max
```

<br>**进程的状态**
　　在Linux中最常用的进程管理命令莫过于ps和top了，它们二者都是用来查看进程信息的，但不同的是前者是静态的，后者会定时更新显示。

``` shell
 PID  USER      PR   NI  VIRT    RES    SHR  S   %CPU %MEM     TIME+    COMMAND
 4589 cutler    20   0  813588 107160  35748 S   6.6  0.7      45:22.78 chromium-b+
 1548 root      20   0 1328780 303416 271036 S   2.3  1.9      9:00.31  Xorg
```
    语句解释：
    -  上面是top命令的输出结果,其中S那一列表示进程当前的状态。

<br>　　进程常见有如下几个状态：

	-  R：正在运行或者处于就绪状态（已经被加入到运行队列等待CPU中），同一时刻可能有多个进程处于可执行状态。
	-  S：可中断的睡眠状态（interruptible sleep），处于这个状态的进程因为等待某个事件的发生（比如等待socket连接、等待信号量）而被挂起。一般情况下，绝大多数进程都处于这个状态。
	-  D：不可终端的睡眠状态（uninterruptible sleep ），通常是在IO操作中（磁盘IO，网络IO等）。
	-  Z：僵尸进程。

<br>　　僵尸进程 & 孤儿进程：

	-  当一个子进程结束运行（一般是调用exit、运行时发生致命错误或收到终止信号所导致）时，子进程的退出状态（返回值）会回报给操作系统，系统则以SIGCHLD信号将子进程被结束的事件告知父进程，此时子进程的进程控制块（PCB）仍驻留在内存中。一般来说，收到SIGCHLD后，父进程会使用wait系统调用以获取子进程的退出状态，然后内核就可以从内存中释放已结束的子进程的PCB；而如若父进程没有这么做的话，子进程的PCB就会一直驻留在内存中，也即成为僵尸进程。
	-  孤儿进程则是指父进程结束后仍在运行的子进程。在类UNIX系统中，孤儿进程一般会被init进程所“收养”，成为init的子进程。
	-  因此解决僵尸进程的问题，可以通过杀死它的父进程来让僵尸成为孤儿，然后被init收养，最后被超度，极乐世界。


<br>
**本节参考阅读：**
- [百度百科 - PCB](http://baike.baidu.com/item/PCB/146397)
- [维基百科 - 父进程](https://zh.wikipedia.org/wiki/%E7%88%B6%E8%BF%9B%E7%A8%8B)
- [Linux内核学习笔记 - 进程的创建过程](http://blog.csdn.net/ddna/article/details/4958058)
- [Linux下进程的创建过程分析(_do_fork/do_fork详解)--Linux进程的管理与调度（八）](http://www.tqcto.com/article/framework/3286.html)
- [Linux process states](https://idea.popcount.org/2012-12-11-linux-process-states/)
- [Linux进程状态解析之R、S、D](http://os.51cto.com/art/201003/185722.htm)




在linux系统中，内核使用进程来控制对CPU和其他系统资源的访问，并且使用进程来决定在CPU上运行哪个程序，运行多久以及采用什么特性运行它。
内核的调度器负责在所有的进程间分配CPU执行时间，称为时间片(time slice)，它轮流在每个进程分得的时间片用完后从进程那里抢回控制权。


每个进程除了一定有PID还会有PPID，也就是父进程ID，通过PPID可以找到父进程的信息。


### 进程通信 ###

在多道程序设计的系统中，由于多个进程可以并发执行，因此进程间必然存在资源共享和相互合作。
扩展：
　多道程序设计技术是指在内存同时放若干道程序，使它们在系统中并发执行，共享系统中的各种资源。当一道程序暂停执行时，CPU立即转去执行另一道程序。

临界区：
前面说，进程间同步的方式有：互斥方式和同步方式。但是如何实现呢？
答：通过临界区+信号量机制来实现。

不论是硬件临界资源，还是软件临界资源，多个进程必须互斥地对它进行访问。每个进程中访问临界资源的那段代码称为临界区(Critical Section)。临界区是隶属于进程的。

临界区管理的原则：
|-  有空则进：当无进程处于临界区时，允许进程进入其自己的临界区，并且只能运行有限的时间。
|-  无空则等：当有一个进程在临界区时，其他需要进入(其自己的)临界区的进程也必须等待。
|-  有限等待：对要求访问临界资源的进程，应保证其等待时间是有限的。以免陷入“饥饿”状态。
|-  让权等待：当进程在临界区门口等待时，应立即释放CPU。使其他进程可以执行。免陷入“忙等”状态。

信号量机制：
PV操作：
|-  PV和栈的弹栈、压栈类似。都是进行增、删的操作。
   |-  P操作表示申请一个资源。
   |-  V操作表示释放一个资源。
|-  PV操作是由进程来控制完成的。

设一个整型变量S，用来保存当前系统中剩余的资源数量。此时：
|-  进行P操作时,S减去1 。
   |-  P从当前系统中申请一个资源，因此当前可用资源S要减少一个。
      |-  执行完P操作后(也就是S-1之后)：
         |-  S>=0 ,说明系统中本来就有资源,申请成功,当前进程继续向下执行。
         |-  S<0 ,说明申请失败。申请失败，则进程就要在此等待，什么时间有资源了，什么时间再次申请。其中|S| = 当前正在等待的进程的个数。
|-  进行V操作时,S 增加1 。
|-  同理,V释放一个已用的资源，因此当前可用资源S要增加一个。
      |-  执行完V操作后(也就是S+1之后)：
         |-  S>0 ,说明系统中现在有空闲资源。
      |-  S<=0 ,说明S原来的值为负数,即系统中有进程正在等待，所以要从等待队列(队首)中取出一个进程，将这个资源，交给它。即唤醒一个进程。然后执行V操作的进程，继续向下执行。

    信号量：
|-  上面使用的变量S就被称为是信号量。对S进行P操作，记作P(S) 。相应的也有V(S) 。
|-  信号量机制分为：
|-  整型信号量。(咱们只讨论整型的信号量)
|-  记录型信号量。
|-  信号量集机制。
    |-  信号量是最早出现的用来解决进程同步与互斥问题的机制,包括一个称为信号量的变量及对它进行的两个原语操作(PV)。

范例1：利用PV操作实现进程互斥。

首先，在内存中，进程A和进程B是并发执行的。谁先执行、谁后执行，是不确定的。
然后，回想一下，互斥操作的含义，以打印机为例，如果A正在使用，则B就只能等待，此时A和B的关系就是互斥。
接着，设信号量S=1。
|-  “临界区”中的代码用来操作“临界资源”。
随后，咱们假设进程A先开始执行。
|-  执行到P(S)时，从系统中申请一个资源，S=S-1 。 此时S = 0 说明申请成功。当前进程进入临界区。假设当A处于其临界区内，正在进行操作的时候，时间片结束了。 
|-  恰巧进程B被分到了CPU时间片，那么A就无法执行了，被挂在了临界区中。
|-  然后B执行到B的P(S)时，从系统中申请一个资源，S=S-1 。 此时S = -1 。而-1意味着申请失败，当前系统中，没有资源了，所以，B进程必须原地等待。B无法进入的临界区中。
|-  由于B的等待，导致CPU→转回到A进程的手中，然后A进程继续操作。
|-  当A进程操作完毕后，从临界区中走出。然后执行V(S) ，来释放一个资源，S=S+1 。 此时S = 0 。说明刚才系统中有进程再等待，A将其唤醒后(这里只是唤醒B，B此时处于就绪状态，在A的时间片没结束前，B只有看的份)，A继续执行其他语句。
|-  过了一会，A进程的CPU时间再次结束，B再次获得CPU控制权，然后直接进入(不再减一)临界区进行操作。
|-  若此时A又回来了，则执行到P(S)时，S = S – 1 。此时S = -1 。因此 A等待。

提示：
进程如果进入等待状态，则需要别的进程将其唤醒。   
进程等待时，不会被分配到CPU时间片。   

再提示：
使用信号量实现进程间互斥操作的时候，信号量的初值必须为>=1 。否则会造成，所有进程都在等待，而临界资源却一直空闲。初值>=1 的信号量被称为公共信号量。

范例2：利用PV操作实现进程同步。
进程同步操作和线程的同步是一样的原理，参看我写的《Java》一书中的第四章 多线程。其中的“厨师与食客”就是一个典型的“生产者与消费者”的例子。
在此，简单的说说“厨师与食客”。
|-  现在有一张桌子，桌子上只能存放5盘菜。
   |-  有一个厨师不断的做菜，然后将菜放到桌子上。如果桌子满了，则就停止做菜。
   |-  有一个食客不断的吃菜。如果桌子空了，则就歇会。
|-  吃菜和放菜不能同时进行。
   |-  若厨师先执行。则厨师一开始检测一下，桌子上的菜是否为5：
|-  如果为5，证明已经满了，则厨师进入等待。CPU此时会转交给食客。
|-  否则，则厨师做一盘菜放到桌子上，并唤醒食客吃。
   |-  若食客先执行。则食客一开始检测一下，桌子上的菜是否为0：
|-  如果为0，证明已经空了，则食客进入等待。CPU此时会转交给厨师。
|-  否则，则食客吃一盘菜，并唤醒厨师继续做。
   


通过观察：
|-  首先，在进程同步的时候需要使用两个信号量。
|-  然后，对某一个信号量的PV操作被分别放到不同的进程中。而在进程互斥中PV操作则存在于同一进程中。
|-  接着，在同步时，信号量的初值为>=0 。初值为>=0 的信号量被称为“私用信号量”。
提示：
使用PV进行同步操作的时候，同样，如果不满足条件，则进程需要在临界区外面等待，当资源充足时，再由另一个进程将其唤醒。
若程序中同时存在互斥和同步操作：
|-  设S1为同步信号量，S2为互斥信号量。
|-  那么P(S1)一定要放在P(S2)之前。否则可能出现死锁。

高级通信原语：
进程间的通信方式
|-  PV通信方式：
   |-  PV属于低级通信。编程难度大，操作不当容易引起死锁，且效率低。
|-  高级通信方式：
   |-  共享存储系统：相互通信的进程共享某些数据结构(或存储区)，实现进程之间的通信。
   |-  消息传递系统：进程间的数据交换以消息为单位，程序员直接利用系统提供的一组通信命令(原语)来实现通信。
      |-  发送消息： send(目的地,消息内容)
      |-  接收消息： receive(消息来源)
   |-  管道通信：
      |-  管道(pipeline)：是连接读写进程的一个特殊的文件，允许进程按先进先出方式传送数据，也能使进程同步执行操作。
      |-  发送进程(进程A)将管道当作输出文件，以字符流形式把大量数据送入管道。
|-  接收进程(进程B)将管道当作输入文件，从管道中接收数据。
|-  这种通信方式叫管道通信。如图所示：


直接通信和间接通信：

直接通信：
|-  顾名思义，两个通信的进程间没有中介物，它们直接进行交流。
   |-  设有A和B两个进程：
|-  A发送数据 send(B,”你好”)
|-  B接受数据 receive(A)
间接通信：
|-  同理，两个通信的进程间有中介物。
   |-  设有A和B两个进程：
      |-  A发送数据 send(C,”你好”)
      |-  B接受数据 receive(C)
|-  间接通信是以信箱为媒体来实现通信的，接受信件的进程只需设立一个信箱，若干个进程可以向同一个进程发送信件。


进程管理又称为处理机管理。
多个进程可以被调度在一个处理器上交替执行，或在多个处理器上同时执行。不同类型的操作系统可能采用不同的调度策略。
单处理器系统：只具有一个CPU。多处理器系统：具有多个CPU。
目前计算机系统可分为如下四类：
 	  |-  单指令流单数据流(Single Instruction Single Data ，SISD)。
         |-  一条指令控制了一个CPU操作一个的数据。
|-  单指令流多数据流(Single Instruction Multiple Data ，SIMD)。
   |-  一条指令控制了多个CPU对不同的数据进行了操作。
  |-  多指令流单数据流(MISD)。
     |-  一个数据流被传送给一组处理器，通过这一组处理器上的不同指令操作最终得到处理结果。该类计算机系统的研究尚在实验室阶段。
  |-  多指令流多数据流(MIMD)。
     |-  多个CPU对各自不同的数据集同时执行不同的指令流。
     |-  分类：
|-  共享内存的紧密耦合 MIMD 系统
   |-  主从式系统 (MSP)
       |-  在一个特别的处理器上运行操作系统内核。
|-  其他处理器上则运行用户程序和操作系统例行程序。
|-  内核负责分配和调度各个处理器，并向其它程序提供各种服务。
|- 如：输入/输出。
                   |-  缺点：主处理器的崩溃会导致整个系统的崩溃。
|-  对称式系统 (SMP)
    |-  操作系统内核可以运行在任意一个处理器上。
|-  每个处理器都可以自我调度运行的进程和线程。
|-  单个进程的多个线程可在不同处理器上同时运行。
|-  内存分布的松散耦合 MIMD 系统
   |-  每个处理单元都有一个独立的内存储器。各个处理单元之间通过网线等相连。多计算机系统和集群(Cluster)系统都是松散耦合 MIMD 系统的例子。

## 进程调度 ##
一个计算机中的CPU数量，一般都低于进程的数量，因此，为了保证进程的执行，需要进行进程调度。

调度的方式：

进程调度方式分为：
|-  可剥夺式：
   |-  当有更高优先级的进程请求CPU服务时，CPU会立刻放弃当前正在执行的进程，转而去为高优先级的进程提供服务。
|-  不可剥夺式：
   |-  和上面的相对应。必须等待当前进程自动放弃CPU后，才将CPU给高优先级的进程使用。

三级调度：
	进程的调度也被称为“处理机的调度”。进程调度分为三级：
|-  高级调度：
   |-  又称为“作业调度”，用来把后续的作业从输入池(外存)调入内存运行。
      |-  在批处理OS中需要使用高级调度，将作业调入内存。
      |-  在实时OS和分时OS中，用户可以直接通过键盘将输入命令。因此，它们不需要高级调度。 而且系统中一个作业只需要经历一次高级调度。
|-  中级调度：
   |-  又称为“对换调度” 在内、外存对换区进行进程对换。
   |-  回想一下，进程挂起就是为了缓和内存紧张，而将进程放到磁盘对换区中。
   |-  中级调度，可以将对换区中的进程，放到内存中来。如果内存紧张，则要先将内存中的阻塞进程放到对换区中，然后再将对换区中的进程取出，即所谓的“对换”。
|-  低级调度：又称为“进程调度”。
|-  它决定内存中就绪队列的哪个进程可以获得CPU。

调度算法：
常用的进程调度算法有如下几种：
|-  先来先服务(FCFS)：
   |-  按照作业提交或者进程变为就绪状态的先后次序分配CPU。
   |-  每当调度进程的时，总是将就绪队列队首的进程投入运行。此种调度方式，有利于CPU繁忙的作业，而不利于IO繁忙的作业。(一个作业老是需要IO操作,但是进程的调度却是先到先服务，IO操作效率低) 。FCFS主要用于宏观调控。
|-  时间片轮转：
   |-  将系统中所有就绪进程按照FCFS原则排成一个队列，每次调用时将CPU分派给队首进程，让其执行一个时间片，时间片一到，发生时钟中断，将该进程送到就绪队列末尾，并切换执行当前的队首进程。主要用于微观调控。
   |-  时间片的长度：
      |-  固定时间片：分给每个进程的时间片相等。
      |-  可变时间片：根据进程不同的要求对时间片的大小实时修改。
|-  优先级调度：
   |- 每一个进程都有一个优先级，进程调度的时候，总是选择优先级高(数值大)的进程。优先级调度分为：
     |-  静态优先级：
        |-  进程的优先级在创建的时候就确定了，直到进程终止都不会改变。
     |-  动态优先级：
        |-  在创建进程时赋予一个优先级，在进程运行过程中还可以改变，以便获得更好的调度性能。
        |-  在就绪队列中，随着等待时间的增长，进程的优先级将提高。当等待足够长的时间后，就可能被调度执行。当每执行完一个时间片后，就降低该进程的优先级。当一个进程持续执行时，其优先级就会降低到让出CPU。
|-  多级反馈调度：
   |-  是时间片轮转法和优先级算法的综合。

2.5  死锁与线程
关于死锁：说白了就是：You first,You first问题。
双方谁都不愿意先做，导致最终相互等待。
比如说：
  ·  抢劫犯要求： 你们先给我钱，我放人。
  ·  受害者家属要求： 你先放人，我们给你钱。

双方都手持着对方想要的东西不放，且还想得到对方的东西。最终结果就是 相互僵持着。这就是死锁。

产生死锁的条件：
|-  互斥条件：
   |-  进程请求占有的资源是临界资源。同一时间只允许一个进程占有。
|-  请求保持条件：
   |-  进程已经占有了一个临界资源。但又提出新的资源申请，其申请占有的资源又被另一个进程占有。于是该进程阻塞，但其原先获得的资源保持不放。
|-  不可剥夺条件：
   |-  进程已获得的资源在未使用完之前，不能被剥夺，只能在使用完后，由自己释放。
|-  环路条件：
   |-  当发生死锁时，在进程资源有向图中存在环路。
      |-  说白了，A进程占有一个临界资源，B进程也占有一个临界资源。
|-  A和B都不想放弃自己的资源，同时又想占有对方的资源。然后就互相等待。

提示：模拟死锁的过程，请参看我写的另一本书《算法设计》 。
 
线程(Thread)

进程是操作系统的基本组成单位。进程既是资源分配单位，又是调度和执行单位。
|-  线程是程序运行的基本单元。  线程隶属于进程。
|-  一个进程中可以有多个线程。当一个进程消失了，那么进程中的所有线程都将死亡。
|-  一个进程中的所有线程，共享进程的内存空间。
|-  一个线程死亡了 进程却可能仍在运行着。线程不是程序，不能独立运行。
|-  多线程 简单的说就是可以使  一个进程在同一个时间段内可以做多个工作。
    
	引入线程的原因：
    |-  在进程的创建、撤销、切换中，系统必须为之付出较大的时候开销。因此在系统中设置的进程数目不能过多，进程切换的频率不宜太高，这就限制了并发程度的提高。因此在现代操作系统中，引入了线程。此时进程仅仅是OS进行资源分配的基本单位，调度的基本单位变为了线程。

提示：
线程被称为轻型进程。
线程与进程的根本区别是把进程作为资源分配单位，而线程是调度和执行的单位。
一个线程中可以建立另一个线程，同一个进程中可以有多个线程并发执行。

一个标准的线程由：线程ID、当前指令指针(PC)、寄存器集合和堆栈组成。同样具有就绪、运行、阻塞三个基本状态。
线程的优点：
|-  创建一个新线程花费的时间少。
|-  两个线程的切换时间少。除了必要的组成部分，线程几乎不拥有资源。
|-  由于同一个进程内的线程共享内存和文件，所以线程之间互相通信必须调用内核。 　　|-  线程能独立执行，能充分利用和发挥处理机与外围设备并行工作的能力。



<br>
**本节参考阅读：**
- [Linux基础：进程管理](http://wuchong.me/blog/2014/07/24/linux-process-manage/)
- [维基百科 - 父进程](https://zh.wikipedia.org/wiki/%E7%88%B6%E8%BF%9B%E7%A8%8B)


2、内存管理

 计算机的内存是主要的资源, 处理它所用的策略对系统性能是至关重要的. 内核为所有进程的每一个都在有限的可用资源上建立了一个虚拟地址空间. 内核的不同部分与内存管理子系统通过一套函数调用交互, 从简单的 malloc/free 对到更多更复杂的功能.

## 内存管理 ##



http://www.cnblogs.com/lcw/p/3159395.html
http://c.biancheng.net/cpp/html/2733.html
http://xuding.blog.51cto.com/4890434/1741861
http://www.ha97.com/1036.html
http://wuchong.me/blog/2014/07/24/linux-process-manage/
https://www.ibm.com/developerworks/cn/linux/kernel/syscall/part2/
http://www.cnblogs.com/vamei/archive/2012/09/20/2694466.html
http://www.cnblogs.com/mickole/p/3185610.html

https://zh.wikipedia.org/wiki/%E7%88%B6%E8%BF%9B%E7%A8%8B
https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%A1%A8


<br><br>
　　







